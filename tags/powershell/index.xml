<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WRISH</title>
    <link>http://www.wrish.com/tags/powershell/index.xml</link>
    <description>Recent content on WRISH</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <atom:link href="http://www.wrish.com/tags/powershell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Assign EMS licenses to all licensed users</title>
      <link>http://www.wrish.com/post/assign-ems-licenses/</link>
      <pubDate>Mon, 13 Feb 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/assign-ems-licenses/</guid>
      <description>&lt;p&gt;Azure conditional access provides amazingly flexible control over access to Office 365 resources and services based on location/user group membership/device etc. Leveraging it to block access generally requires EMS (Enterprise Mobility + Security) licenses for all users. This short script will assign EMS licenses to all users in your tenant who are licensed but do not have EMS yet.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$VerbosePreference = &amp;quot;Continue&amp;quot;
$SKU = get-msolaccountSKU | ?{$_.accountskuid -match &#39;:EMS$&#39;} | select -expand AccountSKUID
if ($SKU) {
    $LicensingFailures = @{}
   $allUsersThatNeedEMS = get-msoluser -all | ?{$_.islicensed -and !($_.licenses | ?{$_.accountskuid -eq $SKU})}
   $allusersThatNeedEMS | %{
        $u = $_;
        try{ 
            Set-MsolUserLicense -UserPrincipalName $u.userprincipalname -AddLicenses $SKU -ErrorAction Stop
            Write-verbose &amp;quot;Successfully added $SKU to $($u.userprincipalname)&amp;quot; 
        } catch {
            Write-Error &amp;quot;Failed to add $SKU to $($u.userprincipalname) because: $_&amp;quot;
            $LicensingFailures.&amp;quot;$($u.userprincipalname)&amp;quot; = $_
        }
    }
    Write-host &amp;quot;The following failures occurred&amp;quot;
    $LicensingFailures
} else {
    Write-host &amp;quot;No EMS license SKU found&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>User Profile Cleanup</title>
      <link>http://www.wrish.com/post/cleanup-user-profiles/</link>
      <pubDate>Mon, 23 Jan 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/cleanup-user-profiles/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Cleanup-UserProfiles-277a8084&#34;&gt;Download Cleanup-UserProfiles.ps1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Big environments get messy, lots of users, lots of admins, lots of logging in here and there.&lt;/p&gt;

&lt;p&gt;Profiles accumulate, C drive starts to get full, oh the humanity! Fear not humble Admin, on our adventures today we discover how to remove old user profiles with naught but the flick of a WMI method.&lt;/p&gt;

&lt;p&gt;The meat and bonse of this function is getting user profiles and deleting them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$userprofiles = Get-WmiObject -Class Win32_UserProfile
$userprofiles[$whichOne].delete()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But before we can pull the trigger and send these profiles to the depths, there will be some evaluation of dates, some checking that they aren&amp;rsquo;t important, and some validating using ShouldProcess.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;[CmdletBinding(
     SupportsShouldProcess=$true,
    ConfirmImpact=&amp;quot;High&amp;quot;
  )]param ($computerName= &#39;.&#39;,$AgeLimit=&#39;60&#39;, $Exclude)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By declaring &lt;code&gt;supportsShouldProcess=$true&lt;/code&gt; it means that we can make use of the COnfirm/Force/Whatif because deleting user profiles is surely an activity to be feared. What if you delete a service account profile? Your best friend Greg? Such activities are the folley of adventurous Admins.&lt;/p&gt;

&lt;p&gt;By wrapping our dangerous bits in &lt;code&gt;$Pscmdlet.shouldProcess(&amp;quot;The thing I am about to do&amp;quot;)&lt;/code&gt; we can give the Admin a chance to save their skin, and their friendships.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt; if ($pscmdlet.ShouldProcess($activity)) {
        Write-Verbose &amp;quot;Attempting to $activity&amp;quot;
        $profile.Delete()       
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go forth wayward Admin, delete those profiles, watch as you recover untold disk space and make the data gods smile.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Cleanup-UserProfiles-277a8084&#34;&gt;Download Cleanup-UserProfiles.ps1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paste an array into a variable</title>
      <link>http://www.wrish.com/post/paste-me-an-array/</link>
      <pubDate>Thu, 19 Jan 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/paste-me-an-array/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve got a list of values, you want that in an array.&lt;/p&gt;

&lt;p&gt;You could copy it to a file, and import it. You could dump it as a string and split it into an array.. or you could &lt;code&gt;Create-ArrayFromPastedText&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;function Create-ArrayFromPastedText ($returnvalue = &amp;quot;&amp;quot;)
{
    $result = @()
    while ($true) {
        $value = read-host    
        if ($value -eq $returnvalue){
            return $result
        } else {
            $result += $value
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use it like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$MyArray = create-Arrayfrompastedtext
#Here is a read-host line, just copy and paste your list of computers/users etc
Item1
Item2
Item3

#when you enter an empty line the array closes and returns
#if you want your array to include empty lines use the -returnvalue paramter to change
#the value that signifies the end of the array.

#And then just use your array
$MyArray |?{$_ -match &#39;[13]&#39;}
Item1
Item3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Check if Office 365 has Your Updated ADFS Certificates</title>
      <link>http://www.wrish.com/post/check-adfs-certificates-with-office365-configuration/</link>
      <pubDate>Sun, 15 Jan 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/check-adfs-certificates-with-office365-configuration/</guid>
      <description>&lt;p&gt;Download it here &lt;a href=&#34;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&#34;&gt;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This script has probably lived its useful life, but I&amp;rsquo;m sharing it anyway, because.. well why not!&lt;/p&gt;

&lt;p&gt;When you want to quickly check to see if your published federation metadata (containing your ADFS token signing certificates) exists on Office 365 you can use &lt;code&gt;Get-MsolFederationProperty&lt;/code&gt; that&amp;rsquo;s great if you have one domain.. but what if you have 25 or 50.&lt;/p&gt;

&lt;p&gt;Create a profile on your ADFS servers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;notepad $profile.alluserscurrenthost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy and paste this into the profile and click save&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;function Check-ADFSFederationForAllDomains {
    
    get-msoldomain | ?{$_.authentication -eq &amp;quot;Federated&amp;quot; -and !$_.rootDomain } | %{
        Write-host Processing $_.Name
        $SETUP = Get-MsolFederationProperty –DomainName $_.Name
        if ($setup[0].TokenSigningCertificate -eq $setup[1].TokenSigningCertificate -and $setup[0].NextTokenSigningCertificate -eq $setup[1].NextTokenSigningCertificate){
            Write-host $_.Name &amp;quot;Token Signing and Next Token Signing Certificates Match&amp;quot; -ForegroundColor Green      
         } else {
            Write-host $_.Name &amp;quot;Token Signing and/or Next Token Signing Certificates DO NOT Match&amp;quot; -ForegroundColor REd    
         }
      } 
}
write-host &#39;Check-ADFSFederationForAllDomains&#39;

Function Update-ADFSFederationForAllDomains ($supportMultipleDomains){
    
    get-msoldomain | ?{$_.authentication -eq &amp;quot;Federated&amp;quot; -and !$_.rootDomain } | %{
        Write-host Processing $_.Name
        Update-MsolFederatedDomain –DomainName $_.Name -SupportMultipleDomain:$supportMultipleDomains
       
      } 
}
Write-Host &#39;Update-ADFSFederationForAllDomains&#39; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when the time comes to check just run &lt;code&gt;Check-ADFSFederationForAllDomains&lt;/code&gt; followed by &lt;code&gt;Update-ADFSFedrationForAllDomains&lt;/code&gt; if you need to update.&lt;/p&gt;

&lt;p&gt;Download it here &lt;a href=&#34;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&#34;&gt;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generate an SHA-1 signed certificate after cutover to SHA-2</title>
      <link>http://www.wrish.com/post/switch-ms-pki-back-to-sha1/</link>
      <pubDate>Wed, 04 Jan 2017 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/switch-ms-pki-back-to-sha1/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve finally made the switch on your Microsoft AD CS PKI infrastructure to SHA2 (SHA256)&amp;hellip; but there is always one.&lt;/p&gt;

&lt;p&gt;One outlier application that won&amp;rsquo;t accept an SHA-2 certificate and needs an SHA1 certificate to keep chugging for 1 more year.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t worry, you can switch your Active Directory Certificate Services PKI infrastructure back to SHA-1 for a little bit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;certutil -setreg ca\csp\CNGHashAlgorithm SHA1
restart-service certsrv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now issue your certificate, and switch back.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;certutil -setreg ca\csp\CNGHashAlgorithm SHA256
restart-service certsrv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that only the leaf certificate will be SHA1, your chain will still be SHA2 - if your application can&amp;rsquo;t handle that then it is out of luck.&lt;/p&gt;

&lt;p&gt;There is a small chance that some auto-enrolled certificate ALSO got issued with an SHA1 certificate. So you can run a quick query to see all the certificates that were issued in the last hour&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;certutil -restrict &amp;quot;SubmittedWhen &amp;gt;= now-00:01, Disposition = 20&amp;quot; -view  csv | ConvertFrom-Csv | fl &amp;quot;Request Submission Date&amp;quot;,&amp;quot;Requester Name&amp;quot;,&amp;quot;Issued Common Name&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you were unlucky and a certificate was issued while you were in SHA1 you may want to go and renew it again.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Office 365 - Convert between Immutable ID and AD Object </title>
      <link>http://www.wrish.com/post/convert-between-immutableid-and-ad-object/</link>
      <pubDate>Thu, 22 Dec 2016 20:53:49 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/convert-between-immutableid-and-ad-object/</guid>
      <description>&lt;p&gt;Two quick scripts to convert between ImmutableIDs and AD Objects with pipeline capability.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;
function get-ImmutableIDfromADObject
{
    [CmdletBinding()] Param(
        [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelinebyPropertyName=$True)]$ADObject) 
   process{ 
        if (!$ADObject.objectguid){$ADObject = get-adobject $AdObject -properties objectGuid}
        [system.convert]::ToBase64String($ADObject.objectguid.tobytearray())
    }
}

function get-ADObjectFromImmutableID{
      [CmdletBinding()] Param(
        [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelinebyPropertyName=$True)][string]$ImmutableID)
   process { get-adobject  ([guid]([system.convert]::FromBase64String($ImmutableID)))}
}

&amp;lt;#
get-aduser shane.wright | get-ImmutableIDfromADObject
6WuADX7LfUa8DVAQGxuZcA==

get-aduser shane.wright | get-ImmutableIDfromADObject | get-ADObjectFromImmutableID

DistinguishedName                          Name         ObjectClass ObjectGUID                          
-----------------                          ----         ----------- ----------                          
CN=Shane Wright,OU=Staff,DC=contoso,DC=com Shane Wright user        0d806be9-cb7e-467d-bc0d-50101b1b9970


get-ADObjectFromImmutableID 6WuADX7LfUa8DVAQGxuZcA==
DistinguishedName                          Name         ObjectClass ObjectGUID                          
-----------------                          ----         ----------- ----------                          
CN=Shane Wright,OU=Staff,DC=contoso,DC=com Shane Wright user        0d806be9-cb7e-467d-bc0d-50101b1b9970
#&amp;gt;

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>List all of a users group memberships</title>
      <link>http://www.wrish.com/post/list-all-nested-memberships/</link>
      <pubDate>Mon, 19 Dec 2016 19:54:49 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/list-all-nested-memberships/</guid>
      <description>

&lt;p&gt;Download the script &lt;a href=&#34;https://gallery.technet.microsoft.com/Get-nested-group-e9ce3687&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Auditing user access is hard, usually you audit from resource out - eg, finding all Domain Admins, or finding all users with full acecss to &lt;em&gt;SecretShare$&lt;/em&gt; share on &lt;em&gt;SecretServer01&lt;/em&gt;. But occasionally want to audit from user out.. this is hard.. even impossible (if you have a very big environment). Lets talk about the first step &lt;em&gt;Enumerating Nested Groups&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;token-groups&#34;&gt;Token Groups&lt;/h2&gt;

&lt;p&gt;Each user has a constructed attribute called &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ms680275(v=vs.85).aspx&#34;&gt;&lt;code&gt;tokengroups&lt;/code&gt;&lt;/a&gt; that returns a list of all transitive group memberships. You can query &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ms680275(v=vs.85).aspx&#34;&gt;&lt;code&gt;tokengroups&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;get-adobject&lt;/code&gt; like this&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt;$userDN = &#39;CN=Tom,OU=sales,DC=wrish,DC=com&#39;
get-adobject -SearchBase $userDN -SearchScope Base -Properties TokenGroups  -filter *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; but there are a couple of problems, you get back SIDs and only SIDs, that means no &lt;em&gt;Distribution Only&lt;/em&gt; groups and you have to manually convert them into objects or DNs if you want useful visual reporting. You can do that pretty easily (but slowly) like this&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function get-TokenGroups ($objectDN) {
    $ADObject = get-adobject -SearchBase $objectDN -SearchScope Base -Properties TokenGroups  -filter *
    foreach ($Sid in $ADObject.tokengroups){
        ([ADSI]&amp;quot;LDAP://&amp;lt;SID=$SID&amp;gt;&amp;quot;).distinguishedname
    }       
}
get-TokenGroups  &#39;CN=Tom,OU=sales,DC=wrish,DC=com&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; also, some groups are missing in a multi-domain environment - &lt;em&gt;Domain Local&lt;/em&gt; groups in remote domains. &lt;em&gt;Domain Local&lt;/em&gt; group memberships aren&amp;rsquo;t replicated to the &lt;em&gt;Global Catalog&lt;/em&gt;, so the GC doesn&amp;rsquo;t add them to the tokengroups value when queried.&lt;/p&gt;

&lt;h2 id=&#34;memberof-evaluation&#34;&gt;MemberOf Evaluation&lt;/h2&gt;

&lt;p&gt;Each user has a &lt;code&gt;MemberOf&lt;/code&gt; attribute which you can query recursively to get at all those juicy remote domain groups. There are plenty of examples of these scripts available they usually commit the various sins of PowerShelling like &lt;a href=&#34;https://gallery.technet.microsoft.com/Export-nested-groups-of-36e761f1&#34;&gt;exporting to csv&lt;/a&gt; or &lt;a href=&#34;https://gallery.technet.microsoft.com/Get-nested-group-15f725f2&#34;&gt;not generating objects at all&lt;/a&gt; or a &lt;a href=&#34;https://gallery.technet.microsoft.com/Get-ADUserNestedGroupMember-d39bb04d&#34;&gt;particularly good one that even outputs some nice verbose info&amp;hellip; but breaks when group memberships traverse domains&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;They are also all incredibly complicated, sigh.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function EnumerateMemberOf($Object, $ResultSoFar=@())
{ 
#Helper function to walk $object&#39;s memberof attribute and list out all group memberships    
    if ($object.memberof){
        $Results =  @();        
        foreach ($group in $Object.memberof){
            #prevent nesting loops trapping by checking to make sure the group hasn&#39;t been searched already
            if ($ResultSoFar -notcontains $Group) {
                #Bind directly to the group with ADSI - this will automatically follow referrals and work with 
                #multi domain forests
                $TempGroup = [ADSI]&amp;quot;LDAP://$Group&amp;quot; ;
                $ResultSoFar += $Group.ToString();
                #Enumerate the next level of memberof
                $Results += EnumerateMemberOf $TempGroup $ResultSoFar ;
                $Results += $Group;
            }            
         }
        return $Results
    } 
}

function get-ADNestedMembership ($Identity) 
    $ADuser = get-aduser $Identity -Properties memberof,distinguishedname,primaryGroup
    write-output (new-object psobject -property @{distinguishedname=$aduser.distinguishedname;&#39;NestedMemberOf&#39;=(@(enumerateMemberof $ADuser)+(enumerateMemberof (get-adgroup $AdUser.primaryGroup -properties memberof)))})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the advanced functions (with pipline goodness) you&amp;rsquo;ll need to download it &lt;a href=&#34;https://gallery.technet.microsoft.com/Get-nested-group-e9ce3687&#34;&gt;https://gallery.technet.microsoft.com/Get-nested-group-e9ce3687&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Clone OU Structure to New Domain</title>
      <link>http://www.wrish.com/post/clone-ou-structure-to-new-domain/</link>
      <pubDate>Fri, 16 Dec 2016 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/clone-ou-structure-to-new-domain/</guid>
      <description>&lt;p&gt;A quick, semi-powershell way to clone an OU structure from a source domain to a destination domain is to use the &lt;code&gt;ldifde&lt;/code&gt; tool and then just modify the output.

To generate the Output file &lt;code&gt;Oustructure-cleaned.ldif&lt;/code&gt; we use ldifde to export all OUs and then remove the domain name (this is not necessary but helps later).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;$Domain = get-addomain
ldifde -f OUStructure.ldif -d $($domain.Distinguishedname) -c `&amp;quot;$($domain.Distinguishedname)`&amp;quot; `&amp;quot;DC=X`&amp;quot; --% -r &amp;quot;(objectclass=organizationalUnit)&amp;quot; -l &amp;quot;ou,description,objectclass,displayName,displayNamePrintable,msCOM-UserPartitionSetLink,x121Address,uPNSuffixes,co,telexNumber,teletexTerminalIdentifier,telephoneNumber,street,st,seeAlso,searchGuide,registeredAddress,preferredDeliveryMethod,postalCode,postalAddress,postOfficeBox,physicalDeliveryOfficeName,managedBy,thumbnailLogo,l,internationalISDNNumber,facsimileTelephoneNumber,destinationIndicator,desktopProfile,defaultGroup,countryCode,c,businessCategory&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can replace any organisation specific information (if you want your test environment to look like a different organisation)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get-content OUStructure.ldif | %{$_ -replace &#39;Contoso&#39;,&#39;TailSpin Toys&#39;} | Out-file Oustructure-reOrg.ldif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we copy the ldif file to the target server and execute the commands to load the OU structure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;$Domain = get-addomain
ldifde -i -v -k -f OUStructure.ldif  -c `&amp;quot;DC=X`&amp;quot; `&amp;quot;$($domain.Distinguishedname)`&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Remotely Retrieve active SSL certificate (HTTPS or LDAPS)</title>
      <link>http://www.wrish.com/post/remotely-retrieve-ssl-certificates/</link>
      <pubDate>Mon, 05 Dec 2016 23:30:10 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/remotely-retrieve-ssl-certificates/</guid>
      <description>&lt;p&gt;When replacing certificates on servers it is nice to be able to verify that the certificate has been updated after you have done the change.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Retreieve-ServerCertFromSoc-baf52fb1&#34;&gt;Download Retrieve-ServerCertFromSocket.ps1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With websites this tends to be very easy - enter the address in Internet Explorer and doubleclick the padlock to view the certificate. This doesn&amp;rsquo;t
work in lots of situations though - no IE available in the environment, when you are trying to use a particular SNI header that doesn&amp;rsquo;t match your connectivity
method on your client machine, or when you want to get a secure LDAP certificate - port 636 or 3269 from a Domain Controller.&lt;/p&gt;

&lt;p&gt;In the past I have often used openssl with the s_client and showcerts options
&lt;code&gt;openssl s_client -showcerts -host www.wrish.com -port 443&lt;/code&gt;
then you have to copy and paste the output into a file to view the file or review the settings. This requires another piece of software, and remembering the parameters. If only there was a quick and dirty powershell way?!&lt;/p&gt;

&lt;p&gt;To build this script I started looking around for what was already available. I found this one &lt;a href=&#34;https://iamoffthebus.wordpress.com/2014/02/04/powershell-to-get-remote-websites-ssl-certificate-expiration/&#34;&gt;Powershell to get remote website&amp;rsquo;s SSL certificate expiration&lt;/a&gt; but knew it wouldn&amp;rsquo;t work
for me because it relies on &lt;code&gt;Net.HttpWebRequest&lt;/code&gt; which means no LDAPs or other protocols. I had to look lower on the network stack and found &lt;code&gt;System.Net.Sockets.tcpclient&lt;/code&gt; and &lt;code&gt;System.Net.Security.SslStream&lt;/code&gt; which allow you to directly establish an SSL stream, perfect!&lt;/p&gt;

&lt;p&gt;To build out the script I make use of &lt;code&gt;try {} catch {} finally {}&lt;/code&gt; by putting the cleanup commands in the finally block (good practice for all network scripting) you can avoid memory leaks and leaving open unwanted sockets.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Retreieve-ServerCertFromSoc-baf52fb1&#34;&gt;Download Retrieve-ServerCertFromSocket.ps1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Decoding legacy Exchange DN from NDR</title>
      <link>http://www.wrish.com/post/decode-legacy-exchange-dn-from-ndr/</link>
      <pubDate>Fri, 02 Dec 2016 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/decode-legacy-exchange-dn-from-ndr/</guid>
      <description>&lt;p&gt;Occasionally in Exchange you will accidentally or intentionally recreate a user, or delete some values from their object - this will impact the LegacyExchangeDN value. I have seen this happen where mailuser objects were removed from Office 365, the user objects were cloud only and the LegacyExchangeDN was gone forever.&lt;/p&gt;

&lt;p&gt;Contrary to its name, the LegacyExchangeDN value is critical to maintaining active conversations within your organisation. When a user&amp;rsquo;s legacyExchagneDN is lost, collegues replying to conversations with that user will get an NDR. When they create a new email the email will work.&lt;/p&gt;

&lt;p&gt;You can extract the old LegacyExchangeDN from the NDR by finding the string that looks like this &lt;code&gt;IMCEAEX-_O=ExchangeLabs_ou=Exchange+20Administrative+20Group+20+28FYDIBOHF23SPDLT+29_cn=Recipients_cn=wrish+2Eonmicrosoft+2Ecom-53453-Jones+2C+20Martial+20+28dfs9vk29@wrish.com&lt;/code&gt; and use the function below to convert it back to an X500 attribute which you add to the &lt;code&gt;proxyaddresses&lt;/code&gt; attribute of the user.&lt;/p&gt;

&lt;p&gt;Here is the function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function decode-NDRX500Address ($DN){
    #Generate a list of replacements to be done
    $replacements = @{&#39;^IMCEAEX-&#39;=&#39;&#39;;&#39;_&#39;=&#39;/&#39;;&#39;@.+$&#39;=&#39;&#39;}
    (0..127) | %{$replacements.&amp;quot;\+$(&#39;{0:x}&#39; -f $_)&amp;quot; = &amp;quot;$([char]$_)&amp;quot;}
    #Add X500 to the start
    $replacements.&amp;quot;^&amp;quot; = &amp;quot;X500:&amp;quot;
    #Perform the replacements
    $replacements.GetEnumerator() | %{
        $dn = $dn -replace $_.key,$_.Value
    }
    $DN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is how you can use it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;$ValueFromNDR = &#39;IMCEAEX-_O=ExchangeLabs_ou=Exchange+20Administrative+20Group+20+28FYDIBOHF23SPDLT+29_cn=Recipients_cn=wrish+2Eonmicrosoft+2Ecom-53453-Jones+2C+20Martial+20+28dfs9vk29@wrish.com&#39;
decode-NDRX500Address $ValueFromNDR
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Track Lync Schema update with Powershell</title>
      <link>http://www.wrish.com/post/track-skype-lync-schema-change/</link>
      <pubDate>Fri, 25 Nov 2016 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/track-skype-lync-schema-change/</guid>
      <description>&lt;p&gt;When I perform schema changes in very large forests it is nice to be able to track the
status of the change as it replicates throughout the forest. I wanted to create a script that
would quickly tell me what the current schema was on over 100 DCs.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t want to see how it was done you can just &lt;a href=&#34;https://gallery.technet.microsoft.com/Track-Skype-and-Lync-c8151bca&#34;&gt;Download Track-LyncSchema.ps1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Starting with some scripts that I have built before &lt;code&gt;foreach-parallel&lt;/code&gt; to do parallel
processing, &lt;code&gt;get-forestDomainControlles&lt;/code&gt; to get a list of all DCs in the forest
and &lt;code&gt;get-LdapData&lt;/code&gt; to do direct ldap lookups quickly. &lt;code&gt;get-LdapData&lt;/code&gt; is necessary
because it will take too long to import the AD module into each thread of the parallel processor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;Import-module ActiveDirectory          
function get-ForestDomainControllers () {...}
function get-ldapData ($ldapfilter,$searchRoot,$Server,[switch]$GC,$pageSize=1000,$Properties=&amp;quot;*&amp;quot;,$sizeLimit=0,[switch]$verbose,$o365FilterAddress){...}
function ForEach-Parallel () {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we need to get all the DCs into an array, this can take a long time for large domains. We will only get the list if $DCs is empty -
this way we can run this script multiple times but only do this step once.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;if ($DCs -eq $null) {$DCs = get-ForestDomainControllers}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we locate the schema partition - likewise we only want to do this once. The &lt;code&gt;PartitionsContainer&lt;/code&gt; value on the AD forest object has a value like &lt;code&gt;DC=Partitions,CN=Configuration,DC=Domain,DC=com&lt;/code&gt;.
We will use &lt;code&gt;-replace&lt;/code&gt; to replace the partitions value with &lt;code&gt;cn=schema&lt;/code&gt; to get the schema partition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;if ($SchemaPartiton -eq $null) {$SchemaPartition = (get-adforest).partitionscontainer -replace &#39;CN=Partitions&#39;,&#39;CN=Schema&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the Lync Schema version we need the rangeUpper value of the ms-RTC-SIP-SchemaVersion object in the schema partition. To do that, we will use &lt;code&gt;get-ldapdata&lt;/code&gt; with the &lt;code&gt;searchroot&lt;/code&gt; specified as the Lync schema object. In this code &lt;code&gt;$_&lt;/code&gt; represents the server being worked on in the pipeline when we do foreach.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;$Value = get-ldapdata  -searchRoot &amp;quot;CN=ms-RTC-SIP-SchemaVersion,$SchemaPartion&amp;quot; -properties rangeupper -server $_ | select -expand rangeupper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ForEach-Parallel&lt;/code&gt; makes use of worker threads for parallelism, so we need to import the functions into the thread and also any values we want to pass. To get the &lt;code&gt;$SchemaPartition&lt;/code&gt; value into the thread, we pass it using the &lt;code&gt;-Arguments&lt;/code&gt; parameter and then the first
line of the executed code includes &lt;code&gt;$SchemaPartition=$args[0]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Depending on the value, we want to return text that tells us what the version is, for this we use a switch statement&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;switch ($value) {
	&#39;1006&#39; {$value = &amp;quot;LCS 2005 [$value]&amp;quot;}
	&#39;1007&#39; {$value = &amp;quot;OCS 2007 R1 [$value]&amp;quot;}
	&#39;1008&#39; {$value = &amp;quot;OCS 2007 R2 [$value]&amp;quot;}
	&#39;1100&#39; {$value = &amp;quot;Lync Server 2010 [$value]&amp;quot;}
	&#39;1150&#39; {$value = &amp;quot;Skype for Business 2015 [$value]&amp;quot;}
	default: {$value = &amp;quot;Unknown schema value or no value [$value]&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we export the value to an object so that it looks like a nice table and we can manipulate it if we want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;new-object psobject -Property @{server=$_;LyncSchemaVersion=$value}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function that does the work looks like this. The &lt;code&gt;foreach-parallel&lt;/code&gt; command ends with &lt;code&gt;-ImportFunctions&lt;/code&gt; to import the &lt;code&gt;get-ldapdata&lt;/code&gt; into scope of each thread.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function track-LyncSchema {
    $DCs.hostname |  %p{
        $SchemaPartition= $args[0]
        $Value = get-ldapdata  -searchRoot &amp;quot;CN=ms-RTC-SIP-SchemaVersion,$SchemaPartition&amp;quot; -properties rangeupper -server $_ | select -expand rangeupper
        switch ($value) {
            &#39;1006&#39; {$value = &amp;quot;LCS 2005 [$value]&amp;quot;}
            &#39;1007&#39; {$value = &amp;quot;OCS 2007 R1 [$value]&amp;quot;}
            &#39;1008&#39; {$value = &amp;quot;OCS 2007 R2 [$value]&amp;quot;}
            &#39;1100&#39; {$value = &amp;quot;Lync Server 2010 [$value]&amp;quot;}
            &#39;1150&#39; {$value = &amp;quot;Skype for Business 2015 [$value]&amp;quot;}
            default {$value = &amp;quot;Unknown [$value]&amp;quot;}
        }

        new-object psobject -Property @{server=$_;LyncSchemaVersion=$value}
    } -ImportFunctions get-ldapData -arguments $schemaPartition
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We call the script from the commandline to get a list of all the servers and the schema version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;. .\track-LyncSchema.ps1
server                        LyncSchemaVersion
------                        -----------------
TestDC100.wrish.com           Skype for Business 2015 [1...
TestDC101.wrish.com           Skype for Business 2015 [1...
TestDC213.wrish.com           Skype for Business 2015 [1...
TestDC12.wrish.com            Skype for Business 2015 [1...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we built the script to output objets, we can easily see how many are left to replicate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;. .\track-lyncschema.ps1 | group LyncSchemaVersion
Count Name                       Group
----- ----                       -----
  202 Skype for Business 2010... {@{server=Test..
   20 Lync Server 2010 [1100]    {@{server=Test..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Track-Skype-and-Lync-c8151bca&#34;&gt;Download Track-LyncSchema.ps1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unable to verify an Azure AD domain</title>
      <link>http://www.wrish.com/post/unable-to-verify-azure-domain/</link>
      <pubDate>Wed, 23 Nov 2016 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/unable-to-verify-azure-domain/</guid>
      <description>&lt;p&gt;After you&amp;rsquo;ve added a domain to Azure AD (or Office 365) using powershell, while connected to your ADFS like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;New-MsolDomain -Name domaintest.wrish.com -Authentication Federated
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you add your verification record and try to verify the domain from the GUI you might get an error like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://www.wrish.com/post/images/unable-to-verify-azure-domain.png&#34; alt=&#34;Unable to verify domain name. Ensure you have added the record above at the registrar &#39;contoso.com&#39;, and try again in a little while&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can&amp;rsquo;t verify your domain using the GUI when you create the Domain using powershell, instead you have to confirm the domain using powershell while entering all Federation options. You will need to pass the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;IssuerURI&lt;/li&gt;
&lt;li&gt;ActiveLogOnUri&lt;/li&gt;
&lt;li&gt;LogOffUri&lt;/li&gt;
&lt;li&gt;PassiveLogOnUri&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can pass whatever you like to these values and then just update the domain federation data afterwards&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;Confirm-MsolDomain -domainname domaintest.wrish.com -IssuerUri http://whatever/ -ActiveLogOnUri https://whatever/ -LogOffUri https://whatever/ -PassiveLogOnUri https://whatever/
Update-MsolFederatedDomain -DomainName domaintest.wrish.com -SupportMultipleDomain $true
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Do it with the command line</title>
      <link>http://www.wrish.com/post/do-it-with-a-command-line/</link>
      <pubDate>Fri, 18 Nov 2016 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/do-it-with-a-command-line/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve built a Windows server without the GUI (Server Core only). You&amp;rsquo;re thinking, I use the command line all the time, this will be easy. It won&amp;rsquo;t. This cheat sheet has a few useful bits and pieces on how to configure it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;#Force Windows Updates
(New-Object -ComObject Microsoft.Update.AutoUpdate).DetectNow()

#Dump the network interface config (to edit it)
  netsh interface dump &amp;gt; netcfg.dat 
#edit the config
   notepad netcfg.dat
#Restore the interface config
   netsh exec netcfg.dat 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Powershell Regex cheat sheet</title>
      <link>http://www.wrish.com/post/regex-cheat-sheet/</link>
      <pubDate>Fri, 18 Nov 2016 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/regex-cheat-sheet/</guid>
      <description>&lt;p&gt;A collection of regex&amp;rsquo;s that I always find myself looking up.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;#Match while tagging match groups
&#39;CowColour Brown&#39; -match &#39;(?&amp;lt;Attribute&amp;gt;\w+) (?&amp;lt;Value&amp;gt;\w+)&#39; | out-null
$matches.Attribute
$matches.Value
#cowColour
#Brown

#Replace to reformat a string 
&#39;This is a wild test&#39; -replace &#39;.*(w[^ ]+).*&#39;,&#39;Not so $1&#39;
#Not so wild

#Lazy matching (to prevent over-matching) use a ? after the + or *
&amp;quot;&amp;lt;h1&amp;gt;MyHeading&amp;lt;/h1&amp;gt;&amp;quot; -replace &#39;&amp;lt;([^/]+?)&amp;gt;&#39;,&#39;&amp;lt;cow&amp;gt;&#39; -replace  &#39;&amp;lt;/([^/]+?)&amp;gt;&#39;,&#39;&amp;lt;/cow&amp;gt;&#39;
#&amp;lt;cow&amp;gt;MyHeading&amp;lt;/cow&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Download file the Powershell way</title>
      <link>http://www.wrish.com/post/downloading-files-with-powershell/</link>
      <pubDate>Mon, 31 Mar 2014 02:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/downloading-files-with-powershell/</guid>
      <description>&lt;p&gt;I was building a lab in Azure today and needed to download the Exchange binaries to extend my test AD schema.&lt;/p&gt;

&lt;p&gt;When you open up IE and browse to the Microsoft download site you have to add a list of 10 or 15 different sites to trusted - some of them are CDNs for shared Javascript code and resources.
&lt;img src=&#34;http://www.wrish.com/post/images/if-you-trust-this-website.png&#34; alt=&#34;Content from the website listed below is being blocked by the Internet Explorer Enhanced Security Configuration https://assets.onestore.ms&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;https://cdn.optimizely.com
https://c.s-microsoft.com
https://query.prod.cms.rt.microsoft.com
https://mem.gfx.ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then&amp;hellip; &lt;em&gt;Your current security settings do not allow this file to be downloaded&lt;/em&gt; sigh!&lt;/p&gt;

&lt;p&gt;Now, I know how to fix this problem properly, but frankly, that is a lot of clicking. Normally I would go and install another browser that isn&amp;rsquo;t weighed down by years of poor security practice&amp;hellip; but.. today I decided to find the PowerShell way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt;Start-BitsTransfer -Source https://download.microsoft.com/download/7/4/9/74981C3B-0D3C-4068-8272-22358F78305F/Exchange2013-x64-cu13.exe -Destination d:\Exchange2013-x64-cu13.exe
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I just attempt to download the file on my machine, and then copy the link and tada! Now I can include this step in my powershell build scripts too! Awesome!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>