<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WRISH</title>
    <link>http://www.wrish.com/tags/powershell/index.xml</link>
    <description>Recent content on WRISH</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <atom:link href="http://www.wrish.com/tags/powershell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Isolate a DC - Part 2: Reset SYSVOL Sync State</title>
      <link>http://www.wrish.com/post/isolate-dc-pt2-reset-sysvol-syncstate/</link>
      <pubDate>Tue, 01 Aug 2017 02:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/isolate-dc-pt2-reset-sysvol-syncstate/</guid>
      <description>

&lt;p&gt;This is Part 2 of a multi part blog post covering the steps to Isolate a Domain Controller - if not emotionally, then logically.&lt;/p&gt;

&lt;h2 id=&#34;reset-your-dfsr-sysvol-state&#34;&gt;Reset your DFSR SYSVol State&lt;/h2&gt;

&lt;p&gt;A DC booting into it&amp;rsquo;s own little world wont become healthy until SYSVOL has completed a sync with a partner in its domain, now this step is optional if your
domain is temporary, but if you ever want to promote a new DC, or have a beautiful clear DCDIAG, then you&amp;rsquo;ll need to force SYSVOL into a &lt;em&gt;synced&lt;/em&gt; state. Not by threatening to put it to bed early, but instead by tweaking its &lt;code&gt;msDFSR-Options&lt;/code&gt; on its &lt;code&gt;SYSVol Subscription&lt;/code&gt; object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function Reset-SYSVOLSyncState{
    set-adobject &amp;quot;cn=sysvol Subscription,cn=domain system volume,cn=dfsr-LocalSettings,$((get-adcomputer $(&amp;amp;hostname)).distinguishedname)&amp;quot; -Replace @{&#39;msDFSR-Options&#39;=1}
    restart-service DFSR
}

Reset-SYSVOLSyncState
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the other parts of this series here:&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Powershell get Exchange Online IP addresses (for Firewall rules)</title>
      <link>http://www.wrish.com/post/quickly-get-exchange-online-ips/</link>
      <pubDate>Thu, 15 Jun 2017 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/quickly-get-exchange-online-ips/</guid>
      <description>&lt;p&gt;This one-liner will download the Office 365 IP list XML file and extract the IPv4 addresses for EOP and Exchange Online.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;([xml](invoke-webrequest -uri https://go.microsoft.com/fwlink/?LinkId=533185) | select-xml -XPath &#39;.//product[@name = &amp;quot;EOP&amp;quot; or @name = &amp;quot;EXO&amp;quot;]//addresslist[@type = &amp;quot;IPv4&amp;quot;]//address&#39;).node.&amp;quot;#text&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using an XPATH filter to examine the XML document for the appropriate data. Like regular expressions for almost all text, understanding XPath can be very helpful for anything that uses XML underneath the covers, like event logs.&lt;/p&gt;

&lt;p&gt;The basic file structure of the XML document looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
    &amp;lt;products updated=&amp;quot;6/6/2017&amp;quot;&amp;gt;
        &amp;lt;product name=&amp;quot;o365&amp;quot;&amp;gt;
            &amp;lt;addresslist type=&amp;quot;IPv6&amp;quot;&amp;gt;
                &amp;lt;address&amp;gt;2603:1020:200::682f:a1d8/128&amp;lt;/address&amp;gt;
                    ...             
            &amp;lt;/addresslist&amp;gt;
            &amp;lt;addresslist type=&amp;quot;IPv4&amp;quot;&amp;gt;
                &amp;lt;address&amp;gt;13.64.196.27/32&amp;lt;/address&amp;gt;              
                    ...
            &amp;lt;/addresslist&amp;gt;
            &amp;lt;addresslist type=&amp;quot;URL&amp;quot;&amp;gt;
                &amp;lt;address&amp;gt;*.aadrm.com&amp;lt;/address&amp;gt;              
                    ...
            &amp;lt;/addresslist&amp;gt;
        &amp;lt;/product&amp;gt;
        &amp;lt;product name=&amp;quot;EOP&amp;quot;&amp;gt;
            ...
        &amp;lt;/product&amp;gt;
    &amp;lt;/products&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Xpath Command &lt;code&gt;.//product[@name = &amp;quot;EOP&amp;quot; or @name = &amp;quot;EXO&amp;quot;]//addresslist[@type = &amp;quot;IPv4&amp;quot;]//address&lt;/code&gt; is saying
Search from the root for a &lt;em&gt;product&lt;/em&gt; with &lt;em&gt;name&lt;/em&gt; attribute of &lt;em&gt;EOP&lt;/em&gt; or &lt;em&gt;EXO&lt;/em&gt; and find &lt;em&gt;addresslist&lt;/em&gt; under it with &lt;em&gt;type&lt;/em&gt; of &lt;em&gt;IPv4&lt;/em&gt;
This gives us all the IPv4 addresses within the products EOP and EXO in CIDR format.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PowerShell Oneliners</title>
      <link>http://www.wrish.com/post/powershell-oneliners/</link>
      <pubDate>Wed, 17 May 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/powershell-oneliners/</guid>
      <description>&lt;p&gt;Just a list of useful oneliners for powershell server and AD management
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;#Retrieve the PDC AD Object using ADSI
$PDC = [adsi]([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://rootdse&amp;quot;).defaultNamingContext)&amp;quot;).fsmoroleowner)&amp;quot;).parent 

#PDC name to the clipboard
([adsi]([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://rootdse&amp;quot;).defaultNamingContext)&amp;quot;).fsmoroleowner)&amp;quot;).parent ).dnshostname | clip

#List all PDCs in the forest (Requires ActiveDirectory powershell module)
get-adforest | select -expand domains | %{Resolve-DnsName &amp;quot;_ldap._tcp.pdc._msdcs.$_&amp;quot; -Type SRV} | ?{$_.querytype -eq &#39;A&#39;} | select name,Address

#On the PDC - check to see if SDPropogation is in progress (if numbers are greater than 0 it is in progress)
get-counter -counter &#39;\directoryservices(ntds)\ds security descriptor propagator runtime queue&#39;,&#39;\directoryservices(ntds)\ds security descriptor propagations events&#39;

#Quickly list dnshostname of all DCs in the forest
(New-Object adsisearcher([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://rootdse&amp;quot;).configurationNamingContext)&amp;quot;,&amp;quot;(objectClass=nTDSDSA)&amp;quot;)).findall() | %{($_.properties.distinguishedname[0] -replace &#39;cn=NTDS Settings,&#39;,&#39;&#39;)} | %{[adsi]&amp;quot;LDAP://$_&amp;quot;} | select -expand dnshostname

#get the last executed command to the clipboard
(get-history)[-1].commandline | clip

#Get the last boot time to a date/time object
wmic os get lastbootuptime | ?{$_ -match &#39;^(?&amp;lt;year&amp;gt;\d\d\d\d)(?&amp;lt;month&amp;gt;\d\d)(?&amp;lt;day&amp;gt;\d\d)&#39;} | %{ (get-date -year $matches.year -month $matches.month -day $matches.day)} 
(get-wmiobject Win32_OperatingSystem -Property lastbootuptime).lastbootuptime 

#get the last boot time to the clipboard
wmic os get lastbootuptime | ?{$_ -match &#39;^(?&amp;lt;year&amp;gt;\d\d\d\d)(?&amp;lt;month&amp;gt;\d\d)(?&amp;lt;day&amp;gt;\d\d)&#39;} | %{ (get-date -year $matches.year -month $matches.month -day $matches.day).tostring()} | clip

#Create a scheduled task to restart the server in x hours 
$hours = 1
schtasks /Create /RU &amp;quot;NT AUTHORITY\SYSTEM&amp;quot; /SC ONCE /st $((get-date).addhours($hours).tostring(&#39;HH:mm&#39;)) /TN My-ScheduledRestart /RL HIGHEST /TR &amp;quot;%windir%\system32\Shutdown.exe /r /t 10&amp;quot; /SD $((get-date).addhours($hours).tostring($([System.Globalization.DateTimeFormatInfo]::CurrentInfo.ShortDatePattern).replace(&#39;M+&#39;, &#39;MM&#39;).replace(&#39;d+&#39;, &#39;dd&#39;)))

#Create a scheduled task to restart at a specific date and time
$date = get-date -hour 21 -minute 30 -day 20
schtasks /Create /RU &amp;quot;NT AUTHORITY\SYSTEM&amp;quot; /SC ONCE /st $(($date).tostring(&#39;HH:mm&#39;)) /TN My-ScheduledRestart /RL HIGHEST /TR &amp;quot;%windir%\system32\Shutdown.exe /r /t 10&amp;quot; /SD $(($date).tostring($([System.Globalization.DateTimeFormatInfo]::CurrentInfo.ShortDatePattern).replace(&#39;M+&#39;, &#39;MM&#39;).replace(&#39;d+&#39;, &#39;dd&#39;)))

#Seize all roles
$domain = &amp;quot;contoso.com&amp;quot;
ntdsutil &amp;quot;roles&amp;quot; con &amp;quot;con to dom $domain&amp;quot; q &amp;quot;Sei PDC&amp;quot; &amp;quot;Sei Inf ma&amp;quot; &amp;quot;sei sch ma&amp;quot; &amp;quot;sei na ma&amp;quot; &amp;quot;sei rid ma&amp;quot; q q

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Isolate a DC - Part 5: Disable Global Catalog</title>
      <link>http://www.wrish.com/post/isolate-dc-pt5-disable-global-catalog/</link>
      <pubDate>Wed, 10 May 2017 02:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/isolate-dc-pt5-disable-global-catalog/</guid>
      <description>

&lt;p&gt;This is Part 5 of a series on Active Directory Forest recovery which requires brining up restored DCs in their own network; bring them up with good manners and we all benefit.&lt;/p&gt;

&lt;h2 id=&#34;disable-global-catalog&#34;&gt;Disable Global Catalog&lt;/h2&gt;

&lt;p&gt;Now this step is strictly for Multi-Domain Forest recoveries. If your domains replicate cross domain boundaries, they&amp;rsquo;ll start complaining about their USNs and nobody wants that. If you&amp;rsquo;ve got yourself a nice simple single Domain environment, don&amp;rsquo;t sweat it and move on your Global Catalog can merrily sing into the night air without anybody noticing.&lt;/p&gt;

&lt;p&gt;I mentioned in &lt;a href=&#34;http://www.wrish.com/post/isolate-dc-pt3-activate-administrator-account&#34;&gt;Part 3: Activate Administrator Account&lt;/a&gt; that only the Administrator could login with the Global Catalog missing, that isn&amp;rsquo;t strictly true. This function will disable the GC on the local server, but also configure &lt;code&gt;IgnoreGCFailures&lt;/code&gt; which conveniently allows anyone to login without a GC! Hurrah for workarounds, just be aware that your login will not include any Universal Group SIDS (because they are in the Global Catalog) which means that &lt;insert wooping siren sounds&gt; there is a possible vulnerability for bypassing Deny permissions set on Universal Groups.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function Disable-GC {
    [CmdletBinding(
    SupportsShouldProcess = $true,
    ConfirmImpact = &#39;High&#39;)]param()
    if ($pscmdlet.ShouldProcess($(&amp;amp;hostname))){
        Write-verbose &amp;quot;Disabling Global Catalog on local server&amp;quot;    
        repadmin.exe /options $(&amp;amp;hostname) –IS_GC 
        Write-Verbose &amp;quot;Setting IgnoreGCFailures so that normal user accounts can login without GC&amp;quot;
        Write-Warning &amp;quot;With IgnoreGCFailures enabled, permissions granted using Universal Groups including deny permissions will not be honoured&amp;quot;
        set-itemproperty -path &amp;quot;HKLM:SYSTEM\CurrentControlSet\Control\Lsa&amp;quot; -Name IgnoreGCFailures -Value 1 
    }
}

Disable-GC
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Extracting objects from commands that output text</title>
      <link>http://www.wrish.com/post/extracting-objects-from-text-certutil/</link>
      <pubDate>Sun, 30 Apr 2017 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/extracting-objects-from-text-certutil/</guid>
      <description>&lt;p&gt;There are many ways to throw a spanner. But if you really must throw it with powershell you&amp;rsquo;ll want it to result in an object.&lt;/p&gt;

&lt;p&gt;The versatility of objects can give much to legacy commands that still linger in the Windows administration world. This short tutorial should teach you to turn most legacy commands into one or more commandlets in some concise code.
&lt;/p&gt;

&lt;h2 id=&#34;step-1-get-your-command&#34;&gt;Step 1 - Get your command&lt;/h2&gt;

&lt;p&gt;First you&amp;rsquo;ll need to find your command, in this case we are going to try to list all CAs in the forest &lt;code&gt;Get-CA&lt;/code&gt; this can be done with &lt;code&gt;certutil -dump&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;certutil -dump

Entry 0:
  Name:                     `Contoso Issuing Certificate Authority&#39;
  Organizational Unit:      `Contoso IT Services&#39;
  Organization:             `Contoso&#39;
  ...
  Country/region:           `US&#39;
  Config:                   `CAServer.contoso.com\IssuingCertificateAuthority&#39;
  ...
  Short Name:               `Contoso Issuing Certificate Authority&#39;
  Sanitized Short Name:     `Contoso Issuing Certificate Authority&#39;
  Flags:                    `1&#39;
  Web Enrollment Servers: 
  ... Some data ...
CertUtil: -dump command completed successfully.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step-2-design-your-regex&#34;&gt;Step 2 - Design your regex&lt;/h2&gt;

&lt;p&gt;The output of &lt;code&gt;certutil -dump&lt;/code&gt; has two key sections &lt;code&gt;Entry 0:&lt;/code&gt; which defines an object delimiter. And &lt;code&gt;Country/region:    `US&#39;&lt;/code&gt; which is the general format of our name value pairs.
&lt;code&gt;&#39;^Entry \d+:&lt;/code&gt; is the first regex we will use. &lt;code&gt;^&lt;/code&gt; represents the start of the line and &lt;code&gt;\d+&lt;/code&gt; represents &amp;ldquo;one or more digits&amp;rdquo; the rest is just direct character matching.
&lt;code&gt;&amp;quot;  (?&amp;lt;variable&amp;gt;[\w\s]+):\s+``(?&amp;lt;value&amp;gt;.*)&#39;&amp;quot;&lt;/code&gt; is the second regex. &lt;code&gt;?&amp;lt;varible&amp;gt;&lt;/code&gt; puts the matched value into a property for use &lt;code&gt;[\w\s]+&lt;/code&gt; matches any number of letter or whitepace characters and &lt;code&gt;.*&lt;/code&gt; is zero or more of any character. Note that the string part of this line starts with a backtick, to include a backtick you need to escape it so `` represents only one backtick.&lt;/p&gt;

&lt;h2 id=&#34;step-3-parse-your-result&#34;&gt;Step 3 - Parse your result&lt;/h2&gt;

&lt;p&gt;This same technique was used to wrap dnscmd before it had native Powershell counterparts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt; #Get the result in a variable
 $result = certutil -dump
 #prepare an array for the objects
    $CAs = @()
    #Parse through the result
    switch -regex ($result){
        &#39;^Entry \d+:&#39;  {
            #When you hit an Entry put the object into the Array and create a new object
            if ($thisEntry){$CAs += $thisEntry}
            $thisEntry = new-object psobject;
        }
        &amp;quot;  (?&amp;lt;variable&amp;gt;[\w\s]+):\s+``(?&amp;lt;value&amp;gt;.*)&#39;&amp;quot;{
            #When you hit a parameter, add it to the object
            $thisEntry | Add-Member -MemberType NoteProperty -Name $matches.variable -value $matches.value -force
        }
    }    
    #If we finish parsing, put the last object in the array
    if ($thisEntry){$CAs += $thisEntry}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that &lt;code&gt;$CAs&lt;/code&gt;` contains our list of CAs!&lt;/p&gt;

&lt;h3 id=&#34;step-4-build-your-function&#34;&gt;Step 4 - Build your function&lt;/h3&gt;

&lt;p&gt;Wrap your code up in a function. As a bonus I have also included a command to list the published templates on each CA.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function get-CAs {
    $result = certutil -dump
    $CAs = @()
    
    switch -regex ($result){
        &#39;^Entry \d+:&#39;  {
            if ($thisEntry){$CAs += $thisEntry}
            $thisEntry = new-object psobject;
        }
        &amp;quot;  (?&amp;lt;variable&amp;gt;[\w\s]+):\s+``(?&amp;lt;value&amp;gt;.*)&#39;&amp;quot;{
            $thisEntry | Add-Member -MemberType NoteProperty -Name $matches.variable -value $matches.value -force
        }
    }    
    if ($thisEntry){$CAs += $thisEntry}
    return $CAs
}

function get-CATemplatesAvailableToIssue ($CA) {
    if (!$CA -or $CA -notmatch &#39;^[\w\.]+\\\w+$&#39;) {
        $CAs = get-CAs
        $CAsToLookup = $CAs | ?{$_.Config -match $CA -or $_.Config -like $CA}
    } else {
        $CAsToLookup = new-object psobject -Property @{Config=$CA}
    }
    foreach ($Ca in $CAsToLookup) {        
        $result = certutil -config $($CA.config) -caTemplates
        switch -regex ($result) {
            &#39;^(?&amp;lt;Name&amp;gt;\w+): (?&amp;lt;DisplayName&amp;gt;.+) -- .+$&#39;{new-object psobject -Property @{Name=$matches.name;DisplayName=$matches.DisplayName;CA=$CA.config}}
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Isolate a DC - Part 4: Reset DSRM Password</title>
      <link>http://www.wrish.com/post/isolate-dc-pt4-reset-dsrm-password/</link>
      <pubDate>Sat, 29 Apr 2017 02:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/isolate-dc-pt4-reset-dsrm-password/</guid>
      <description>

&lt;p&gt;This is Part 4 of a multi part blog post on Domain Recovery and DC Isolation with the aid of Powershell in todays installment we learn that Directory Services Restore Mode (DSRM) is not actually needed to perform a full forest recovery.&lt;/p&gt;

&lt;h2 id=&#34;reset-dsrm-password&#34;&gt;Reset DSRM Password&lt;/h2&gt;

&lt;p&gt;Another typically unnecessary step is getting your hands on your DSRM password - if you don&amp;rsquo;t already have it. DSRM password is only used in DSRM mode, which you don&amp;rsquo;t need for this fun exercise, but why not have it just in case!&lt;/p&gt;

&lt;p&gt;Now this step is not really Powershell, and not really automated, if you wanted to do the later you could probably create an account, set its password, and then sync the password to the DSRM Administrator account, but I wasn&amp;rsquo;t feeling that energetic this morning. So just type your password a couple of times and be done with it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function Reset-DSRMPassword (){
    Write-verbose &amp;quot;Calling NTDSUtil to reset the DSRM password on the local server&amp;quot;
    ntdsutil &amp;quot;set DSRM Password&amp;quot; &amp;quot;Reset Password on Server NULL&amp;quot; q q
}

Reset-DSRMPassword
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Isolate a DC - Part 3: Activate Administrator Account</title>
      <link>http://www.wrish.com/post/isolate-dc-pt3-activate-administrator-account/</link>
      <pubDate>Sun, 23 Apr 2017 02:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/isolate-dc-pt3-activate-administrator-account/</guid>
      <description>

&lt;p&gt;This is Part 3 of a multi part blog post automating AD Forest Recovery, take your forest to rehab, sit it down and force it not to have any AD corruption.&lt;/p&gt;

&lt;h2 id=&#34;activate-administrator-account&#34;&gt;Activate Administrator Account&lt;/h2&gt;

&lt;p&gt;Now I am not one for a false sense of security, but people building environments that I support are. That is why, more often than not, the Administrator account is renamed, the password is divided in 2 and stored at different ends of the earth, one under the 6 watchful eyes of Cerberus the other stuffed in a filing cabinet lost to the ages. Of course, one day you will need to promote a DC, or do a Schema change and so you have people with Domain Admin accounts. However, the Administrator account is the only one that can login if you don&amp;rsquo;t have a Global Catalog available&amp;hellip; so&amp;hellip; just in case, lets make all that skullduggery moot by ressurecting that Administrator account.&lt;/p&gt;

&lt;p&gt;This script will devine your Admin account Samaccountname with nothing but two sticks and a well known SID. Ensure it is enabled, and set its password to something easy to remember that is conveniently printed to the screen.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function Activate-AdminAccount{
    [CmdletBinding(
    SupportsShouldProcess = $true,
    ConfirmImpact = &#39;High&#39;)]
    param($PlainTextPassword)
        
    #Identify and enable the Admin account (note that password will be reset)
    $domainObj = get-addomain 
    $AdminAccount = ([ADSI]&amp;quot;LDAP://&amp;lt;SID=$($domainObj.Domainsid)-500&amp;gt;&amp;quot;).distinguishedname[0]
    Write-Verbose &amp;quot;AD Admin account located $AdminAccount&amp;quot;    
    get-aduser $AdminAccount -properties Samaccountname  |fl Samaccountname,@{l=&#39;Password&#39;;e={$PlainTextPassword}}     
    if ($pscmdlet.ShouldProcess($adminAccount)){
        Write-verbose &amp;quot;Activating $AdminAccount and resetting password to $plainTextPassword&amp;quot;
        $password = (ConvertTo-SecureString -AsPlainText $plainTextPassword -Force) 
        set-adaccountpassword -Identity &amp;quot;$($domainObj.Domainsid)-500&amp;quot; -reset -newpassword $password
        set-aduser $AdminAccount -Enabled $true
    }    
} 

Activate-AdminAccount -plainTextPassword &amp;quot;ThisIsTheMostC0mplexPasswordICou1dThinkOf&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>import-svclog to import SVCLOG files</title>
      <link>http://www.wrish.com/post/use-powershell-to-open-svclog-files/</link>
      <pubDate>Tue, 18 Apr 2017 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/use-powershell-to-open-svclog-files/</guid>
      <description>&lt;p&gt;The Intune connectors dump all their useful information to .svclog files. You can read these files wtih svcTraceViewer.exe which you can get by installing the Windows Communication Foundation SDK.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t want to download the SDK just to get one tool? Do not fear - they are just XML. Here is an imperfect script for reading svclog files.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;function Import-SVCLog {
 [cmdletbinding()]
    Param (
        [parameter(ValueFromPipeline=$True)]
        [string[]]$FileName
    )    
    Process {
       ([xml](&amp;quot;&amp;lt;LogRoot&amp;gt;&amp;quot; + (get-content $fileName) + &amp;quot;&amp;lt;/LogRoot&amp;gt;&amp;quot; )).LogRoot.e2etraceevent | %{            
            $_ | select @{l=&#39;EventID&#39;;e={$_.system.EventID}},@{l=&#39;Type&#39;;e={$_.system.Type}},@{l=&#39;TimeCreated&#39;;e={$_.system.TimeCreated.SystemTime}},@{l=&#39;Source&#39;;e={$_.system.Source.Name}},@{l=&#39;Correlation&#39;;e={$_.system.Correlation.activityID}},@{l=&#39;Computer&#39;;e={$_.system.Computer}},@{l=&#39;Info&#39;;e={$_.ApplicationData}}                       
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy the script into your powershell context and then use it like this (for the Exchange connector)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;cd &amp;quot;C:\ProgramData\Microsoft\Windows Intune Exchange Connector\Logs&amp;quot;
dir | import-svclog | out-gridView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will get a neat graphical interface to sort and view the event data.&lt;/p&gt;

&lt;p&gt;Note that the path to most of the log files for the PKI connector is &lt;code&gt;C:\Program Files\Microsoft Intune\NDESConnectorSvc\Logs\Logs&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Isolate a DC - Part 1: Configure the Network</title>
      <link>http://www.wrish.com/post/isolate-dc-pt1-configure-the-network/</link>
      <pubDate>Wed, 05 Apr 2017 02:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/isolate-dc-pt1-configure-the-network/</guid>
      <description>

&lt;p&gt;Dragging a single Domain Controller by its nostril into an isolated network can be time consuming. For testing or disaster recovery, the steps are the same, and while well documented almost everywhere, there don&amp;rsquo;t seem to be any quick and dirty tools to do the steps for you. That is why I wrote this series of powershell functions that can be applied to a DC you have restored in your Virtual environment to get your test Forest up and running quickly.&lt;/p&gt;

&lt;p&gt;Note that all these functions are design to work in Windows 2012 R2 or higher, and while they&amp;rsquo;ve been tested, they are designed to do serious damage to your test environment and should never be used in production.&lt;/p&gt;

&lt;h2 id=&#34;configure-the-network&#34;&gt;Configure the Network&lt;/h2&gt;

&lt;p&gt;Configure the network card of your restored Domain Controller such that it points only to itself for DNS. Your Domain Controller needs to be able to locate itself when it is starting up to become healthy. So DNS and the network stack need to be operational. Make sure your Network is not connected externally. Having multiple DCs communicating on the same Name/IP Address/Domain Enviornment is unhealthy for your long term career prospects.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll need to know your desired IP and subnet mask.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function ConfigureDCNetwork {
    [CmdletBinding(
    SupportsShouldProcess = $true,
    ConfirmImpact = &#39;High&#39;)]    
    param([parameter(mandatory=$true,
    HelpMessage=&amp;quot;Enter the IP Address this server will use&amp;quot;)][ValidatePattern(&#39;\b(?:\d{1,3}\.){3}\d{1,3}\b&#39;)][string]$IPAddress,
    [parameter(mandatory=$true,HelpMessage=&amp;quot;Enter the number of bits in the subnet mask eg 24 = 255.255.255.0&amp;quot;)][ValidateRange(2,30)]$CIDRSubnet,
    [parameter(mandatory=$true,HelpMessage=&amp;quot;Enter the default gateway IP address&amp;quot;)][ValidatePattern(&#39;\b(?:\d{1,3}\.){3}\d{1,3}\b&#39;)][string]$DefaultGateway)
    Write-Warning &amp;quot;Changing the IP address may result in lost network connectivity - ensure you have console access to this host&amp;quot;
    if ($pscmdlet.ShouldProcess($(&amp;amp;hostname))){  
        $netadapter = Get-NetAdapter | select -first 1
        Write-verbose &amp;quot;Disabling DHCP on first interface&amp;quot;
        $netadapter | Set-NetIPInterface -DHCP Disabled
        Write-verbose &amp;quot;Configuring Network Address and default gateway&amp;quot;
        $netadapter | New-NetIPAddress -AddressFamily IPv4 -IPAddress $IPAddress -PrefixLength $CIDRSubnet -Type Unicast -DefaultGateway $DefaultGateway
        Write-Verbose &amp;quot;Pointing Domain Controller at self for DNS&amp;quot;
        Set-DnsClientServerAddress -InterfaceAlias $netadapter.Name -ServerAddresses $IPAddress  
    }
}
#                 IP Address  Prefix Default Gateway
ConfigureDCNetwork 192.168.1.10 24 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Assign EMS licenses to all licensed users</title>
      <link>http://www.wrish.com/post/assign-ems-licenses/</link>
      <pubDate>Mon, 13 Feb 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/assign-ems-licenses/</guid>
      <description>&lt;p&gt;Azure conditional access provides amazingly flexible control over access to Office 365 resources and services based on location/user group membership/device etc. Leveraging it to block access generally requires EMS (Enterprise Mobility + Security) licenses for all users. This short script will assign EMS licenses to all users in your tenant who are licensed but do not have EMS yet.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$VerbosePreference = &amp;quot;Continue&amp;quot;
$SKU = get-msolaccountSKU | ?{$_.accountskuid -match &#39;:EMS$&#39;} | select -expand AccountSKUID
if ($SKU) {
    $LicensingFailures = @{}
   $allUsersThatNeedEMS = get-msoluser -all | ?{$_.islicensed -and !($_.licenses | ?{$_.accountskuid -eq $SKU})}
   $allusersThatNeedEMS | %{
        $u = $_;
        try{ 
            Set-MsolUserLicense -UserPrincipalName $u.userprincipalname -AddLicenses $SKU -ErrorAction Stop
            Write-verbose &amp;quot;Successfully added $SKU to $($u.userprincipalname)&amp;quot; 
        } catch {
            Write-Error &amp;quot;Failed to add $SKU to $($u.userprincipalname) because: $_&amp;quot;
            $LicensingFailures.&amp;quot;$($u.userprincipalname)&amp;quot; = $_
        }
    }
    Write-host &amp;quot;The following failures occurred&amp;quot;
    $LicensingFailures
} else {
    Write-host &amp;quot;No EMS license SKU found&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>User Profile Cleanup</title>
      <link>http://www.wrish.com/post/cleanup-user-profiles/</link>
      <pubDate>Mon, 23 Jan 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/cleanup-user-profiles/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Cleanup-UserProfiles-277a8084&#34;&gt;Download Cleanup-UserProfiles.ps1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Big environments get messy, lots of users, lots of admins, lots of logging in here and there.&lt;/p&gt;

&lt;p&gt;Profiles accumulate, C drive starts to get full, oh the humanity! Fear not humble Admin, on our adventures today we discover how to remove old user profiles with naught but the flick of a WMI method.&lt;/p&gt;

&lt;p&gt;The meat and bonse of this function is getting user profiles and deleting them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$userprofiles = Get-WmiObject -Class Win32_UserProfile
$userprofiles[$whichOne].delete()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But before we can pull the trigger and send these profiles to the depths, there will be some evaluation of dates, some checking that they aren&amp;rsquo;t important, and some validating using ShouldProcess.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;[CmdletBinding(
     SupportsShouldProcess=$true,
    ConfirmImpact=&amp;quot;High&amp;quot;
  )]param ($computerName= &#39;.&#39;,$AgeLimit=&#39;60&#39;, $Exclude)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By declaring &lt;code&gt;supportsShouldProcess=$true&lt;/code&gt; it means that we can make use of the COnfirm/Force/Whatif because deleting user profiles is surely an activity to be feared. What if you delete a service account profile? Your best friend Greg? Such activities are the folley of adventurous Admins.&lt;/p&gt;

&lt;p&gt;By wrapping our dangerous bits in &lt;code&gt;$Pscmdlet.shouldProcess(&amp;quot;The thing I am about to do&amp;quot;)&lt;/code&gt; we can give the Admin a chance to save their skin, and their friendships.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt; if ($pscmdlet.ShouldProcess($activity)) {
        Write-Verbose &amp;quot;Attempting to $activity&amp;quot;
        $profile.Delete()       
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go forth wayward Admin, delete those profiles, watch as you recover untold disk space and make the data gods smile.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Cleanup-UserProfiles-277a8084&#34;&gt;Download Cleanup-UserProfiles.ps1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paste an array into a variable</title>
      <link>http://www.wrish.com/post/paste-me-an-array/</link>
      <pubDate>Thu, 19 Jan 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/paste-me-an-array/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve got a list of values, you want that in an array.&lt;/p&gt;

&lt;p&gt;You could copy it to a file, and import it. You could dump it as a string and split it into an array.. or you could &lt;code&gt;Create-ArrayFromPastedText&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;function Create-ArrayFromPastedText ($returnvalue = &amp;quot;&amp;quot;)
{
    $result = @()
    while ($true) {
        $value = read-host    
        if ($value -eq $returnvalue){
            return $result
        } else {
            $result += $value
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use it like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$MyArray = create-Arrayfrompastedtext
#Here is a read-host line, just copy and paste your list of computers/users etc
Item1
Item2
Item3

#when you enter an empty line the array closes and returns
#if you want your array to include empty lines use the -returnvalue paramter to change
#the value that signifies the end of the array.

#And then just use your array
$MyArray |?{$_ -match &#39;[13]&#39;}
Item1
Item3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Check if Office 365 has Your Updated ADFS Certificates</title>
      <link>http://www.wrish.com/post/check-adfs-certificates-with-office365-configuration/</link>
      <pubDate>Sun, 15 Jan 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/check-adfs-certificates-with-office365-configuration/</guid>
      <description>&lt;p&gt;Download it here &lt;a href=&#34;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&#34;&gt;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This script has probably lived its useful life, but I&amp;rsquo;m sharing it anyway, because.. well why not!&lt;/p&gt;

&lt;p&gt;When you want to quickly check to see if your published federation metadata (containing your ADFS token signing certificates) exists on Office 365 you can use &lt;code&gt;Get-MsolFederationProperty&lt;/code&gt; that&amp;rsquo;s great if you have one domain.. but what if you have 25 or 50.&lt;/p&gt;

&lt;p&gt;Create a profile on your ADFS servers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;notepad $profile.alluserscurrenthost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy and paste this into the profile and click save&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;function Check-ADFSFederationForAllDomains {
    
    get-msoldomain | ?{$_.authentication -eq &amp;quot;Federated&amp;quot; -and !$_.rootDomain } | %{
        Write-host Processing $_.Name
        $SETUP = Get-MsolFederationProperty –DomainName $_.Name
        if ($setup[0].TokenSigningCertificate -eq $setup[1].TokenSigningCertificate -and $setup[0].NextTokenSigningCertificate -eq $setup[1].NextTokenSigningCertificate){
            Write-host $_.Name &amp;quot;Token Signing and Next Token Signing Certificates Match&amp;quot; -ForegroundColor Green      
         } else {
            Write-host $_.Name &amp;quot;Token Signing and/or Next Token Signing Certificates DO NOT Match&amp;quot; -ForegroundColor REd    
         }
      } 
}
write-host &#39;Check-ADFSFederationForAllDomains&#39;

Function Update-ADFSFederationForAllDomains ($supportMultipleDomains){
    
    get-msoldomain | ?{$_.authentication -eq &amp;quot;Federated&amp;quot; -and !$_.rootDomain } | %{
        Write-host Processing $_.Name
        Update-MsolFederatedDomain –DomainName $_.Name -SupportMultipleDomain:$supportMultipleDomains
       
      } 
}
Write-Host &#39;Update-ADFSFederationForAllDomains&#39; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when the time comes to check just run &lt;code&gt;Check-ADFSFederationForAllDomains&lt;/code&gt; followed by &lt;code&gt;Update-ADFSFedrationForAllDomains&lt;/code&gt; if you need to update.&lt;/p&gt;

&lt;p&gt;Download it here &lt;a href=&#34;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&#34;&gt;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generate an SHA-1 signed certificate after cutover to SHA-2</title>
      <link>http://www.wrish.com/post/switch-ms-pki-back-to-sha1/</link>
      <pubDate>Wed, 04 Jan 2017 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/switch-ms-pki-back-to-sha1/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve finally made the switch on your Microsoft AD CS PKI infrastructure to SHA2 (SHA256)&amp;hellip; but there is always one.&lt;/p&gt;

&lt;p&gt;One outlier application that won&amp;rsquo;t accept an SHA-2 certificate and needs an SHA1 certificate to keep chugging for 1 more year.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t worry, you can switch your Active Directory Certificate Services PKI infrastructure back to SHA-1 for a little bit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;certutil -setreg ca\csp\CNGHashAlgorithm SHA1
restart-service certsvc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now issue your certificate, and switch back.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;certutil -setreg ca\csp\CNGHashAlgorithm SHA256
restart-service certsvc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that only the leaf certificate will be SHA1, your chain will still be SHA2 - if your application can&amp;rsquo;t handle that then it is out of luck.&lt;/p&gt;

&lt;p&gt;There is a small chance that some auto-enrolled certificate ALSO got issued with an SHA1 certificate. So you can run a quick query to see all the certificates that were issued in the last hour&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;certutil -restrict &amp;quot;SubmittedWhen &amp;gt;= now-00:01, Disposition = 20&amp;quot; -view  csv | ConvertFrom-Csv | fl &amp;quot;Request Submission Date&amp;quot;,&amp;quot;Requester Name&amp;quot;,&amp;quot;Issued Common Name&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you were unlucky and a certificate was issued while you were in SHA1 you may want to go and renew it again.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Office 365 - Convert between Immutable ID and AD Object </title>
      <link>http://www.wrish.com/post/convert-between-immutableid-and-ad-object/</link>
      <pubDate>Thu, 22 Dec 2016 20:53:49 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/convert-between-immutableid-and-ad-object/</guid>
      <description>&lt;p&gt;Two quick scripts to convert between ImmutableIDs and AD Objects with pipeline capability.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;
function get-ImmutableIDfromADObject
{
    [CmdletBinding()] Param(
        [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelinebyPropertyName=$True)]$ADObject) 
   process{ 
        if (!$ADObject.objectguid){$ADObject = get-adobject $AdObject -properties objectGuid}
        [system.convert]::ToBase64String($ADObject.objectguid.tobytearray())
    }
}

function get-ADObjectFromImmutableID{
      [CmdletBinding()] Param(
        [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelinebyPropertyName=$True)][string]$ImmutableID)
   process { get-adobject  ([guid]([system.convert]::FromBase64String($ImmutableID)))}
}

&amp;lt;#
get-aduser shane.wright | get-ImmutableIDfromADObject
6WuADX7LfUa8DVAQGxuZcA==

get-aduser shane.wright | get-ImmutableIDfromADObject | get-ADObjectFromImmutableID

DistinguishedName                          Name         ObjectClass ObjectGUID                          
-----------------                          ----         ----------- ----------                          
CN=Shane Wright,OU=Staff,DC=contoso,DC=com Shane Wright user        0d806be9-cb7e-467d-bc0d-50101b1b9970


get-ADObjectFromImmutableID 6WuADX7LfUa8DVAQGxuZcA==
DistinguishedName                          Name         ObjectClass ObjectGUID                          
-----------------                          ----         ----------- ----------                          
CN=Shane Wright,OU=Staff,DC=contoso,DC=com Shane Wright user        0d806be9-cb7e-467d-bc0d-50101b1b9970
#&amp;gt;

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>