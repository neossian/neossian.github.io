<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WRISH</title>
    <link>http://www.wrish.com/tags/powershell/index.xml</link>
    <description>Recent content on WRISH</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&amp;copy; 2016. All rights reserved.</copyright>
    <atom:link href="http://www.wrish.com/tags/powershell/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Powershell get Exchange Online IP addresses (for Firewall rules)</title>
      <link>http://www.wrish.com/post/quickly-get-exchange-online-ips/</link>
      <pubDate>Thu, 15 Jun 2017 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/quickly-get-exchange-online-ips/</guid>
      <description>&lt;p&gt;This one-liner will download the Office 365 IP list XML file and extract the IPv4 addresses for EOP and Exchange Online.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;([xml](invoke-webrequest -uri https://go.microsoft.com/fwlink/?LinkId=533185) | select-xml -XPath &#39;.//product[@name = &amp;quot;EOP&amp;quot; or @name = &amp;quot;EXO&amp;quot;]//addresslist[@type = &amp;quot;IPv4&amp;quot;]//address&#39;).node.&amp;quot;#text&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We are using an XPATH filter to examine the XML document for the appropriate data. Like regular expressions for almost all text, understanding XPath can be very helpful for anything that uses XML underneath the covers, like event logs.&lt;/p&gt;

&lt;p&gt;The basic file structure of the XML document looks like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
    &amp;lt;products updated=&amp;quot;6/6/2017&amp;quot;&amp;gt;
        &amp;lt;product name=&amp;quot;o365&amp;quot;&amp;gt;
            &amp;lt;addresslist type=&amp;quot;IPv6&amp;quot;&amp;gt;
                &amp;lt;address&amp;gt;2603:1020:200::682f:a1d8/128&amp;lt;/address&amp;gt;
                    ...             
            &amp;lt;/addresslist&amp;gt;
            &amp;lt;addresslist type=&amp;quot;IPv4&amp;quot;&amp;gt;
                &amp;lt;address&amp;gt;13.64.196.27/32&amp;lt;/address&amp;gt;              
                    ...
            &amp;lt;/addresslist&amp;gt;
            &amp;lt;addresslist type=&amp;quot;URL&amp;quot;&amp;gt;
                &amp;lt;address&amp;gt;*.aadrm.com&amp;lt;/address&amp;gt;              
                    ...
            &amp;lt;/addresslist&amp;gt;
        &amp;lt;/product&amp;gt;
        &amp;lt;product name=&amp;quot;EOP&amp;quot;&amp;gt;
            ...
        &amp;lt;/product&amp;gt;
    &amp;lt;/products&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Xpath Command &lt;code&gt;.//product[@name = &amp;quot;EOP&amp;quot; or @name = &amp;quot;EXO&amp;quot;]//addresslist[@type = &amp;quot;IPv4&amp;quot;]//address&lt;/code&gt; is saying
Search from the root for a &lt;em&gt;product&lt;/em&gt; with &lt;em&gt;name&lt;/em&gt; attribute of &lt;em&gt;EOP&lt;/em&gt; or &lt;em&gt;EXO&lt;/em&gt; and find &lt;em&gt;addresslist&lt;/em&gt; under it with &lt;em&gt;type&lt;/em&gt; of &lt;em&gt;IPv4&lt;/em&gt;
This gives us all the IPv4 addresses within the products EOP and EXO in CIDR format.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PowerShell Oneliners</title>
      <link>http://www.wrish.com/post/powershell-oneliners/</link>
      <pubDate>Wed, 17 May 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/powershell-oneliners/</guid>
      <description>&lt;p&gt;Just a list of useful oneliners for powershell server and AD management
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;#Retrieve the PDC AD Object using ADSI
$PDC = [adsi]([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://rootdse&amp;quot;).defaultNamingContext)&amp;quot;).fsmoroleowner)&amp;quot;).parent 

#PDC name to the clipboard
([adsi]([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://rootdse&amp;quot;).defaultNamingContext)&amp;quot;).fsmoroleowner)&amp;quot;).parent ).dnshostname | clip

#Quickly list dnshostname of all DCs in the forest
(New-Object adsisearcher([adsi]&amp;quot;LDAP://$(([adsi]&amp;quot;LDAP://rootdse&amp;quot;).configurationNamingContext)&amp;quot;,&amp;quot;(objectClass=nTDSDSA)&amp;quot;)).findall() | %{($_.properties.distinguishedname[0] -replace &#39;cn=NTDS Settings,&#39;,&#39;&#39;)} | %{[adsi]&amp;quot;LDAP://$_&amp;quot;} | select -expand dnshostname

#get the last executed command to the clipboard
(get-history)[-1].commandline | clip

#Get the last boot time to a date/time object
wmic os get lastbootuptime | ?{$_ -match &#39;^(?&amp;lt;year&amp;gt;\d\d\d\d)(?&amp;lt;month&amp;gt;\d\d)(?&amp;lt;day&amp;gt;\d\d)&#39;} | %{ (get-date -year $matches.year -month $matches.month -day $matches.day)} 
(get-wmiobject Win32_OperatingSystem -Property lastbootuptime).lastbootuptime 

#get the last boot time to the clipboard
wmic os get lastbootuptime | ?{$_ -match &#39;^(?&amp;lt;year&amp;gt;\d\d\d\d)(?&amp;lt;month&amp;gt;\d\d)(?&amp;lt;day&amp;gt;\d\d)&#39;} | %{ (get-date -year $matches.year -month $matches.month -day $matches.day).tostring()} | clip

#Create a scheduled task to restart the server in x hours 
$hours = 1
schtasks /Create /RU &amp;quot;NT AUTHORITY\SYSTEM&amp;quot; /SC ONCE /st $((get-date).addhours($hours).tostring(&#39;hh:mm&#39;)) /TN My-ScheduledRestart /RL HIGHEST /TR &amp;quot;%windir%\system32\Shutdown.exe /r /t 10&amp;quot; /SD $((get-date).addhours($hours).tostring(&#39;MM/dd/yyyy&#39;))


&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Extracting objects from commands that output text</title>
      <link>http://www.wrish.com/post/extracting-objects-from-text-certutil/</link>
      <pubDate>Sun, 30 Apr 2017 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/extracting-objects-from-text-certutil/</guid>
      <description>&lt;p&gt;There are many ways to throw a spanner. But if you really must throw it with powershell you&amp;rsquo;ll want it to result in an object.&lt;/p&gt;

&lt;p&gt;The versatility of objects can give much to legacy commands that still linger in the Windows administration world. This short tutorial should teach you to turn most legacy commands into one or more commandlets in some concise code.
&lt;/p&gt;

&lt;h2 id=&#34;step-1-get-your-command&#34;&gt;Step 1 - Get your command&lt;/h2&gt;

&lt;p&gt;First you&amp;rsquo;ll need to find your command, in this case we are going to try to list all CAs in the forest &lt;code&gt;Get-CA&lt;/code&gt; this can be done with &lt;code&gt;certutil -dump&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-none&#34;&gt;certutil -dump

Entry 0:
  Name:                     `Contoso Issuing Certificate Authority&#39;
  Organizational Unit:      `Contoso IT Services&#39;
  Organization:             `Contoso&#39;
  ...
  Country/region:           `US&#39;
  Config:                   `CAServer.contoso.com\IssuingCertificateAuthority&#39;
  ...
  Short Name:               `Contoso Issuing Certificate Authority&#39;
  Sanitized Short Name:     `Contoso Issuing Certificate Authority&#39;
  Flags:                    `1&#39;
  Web Enrollment Servers: 
  ... Some data ...
CertUtil: -dump command completed successfully.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step-2-design-your-regex&#34;&gt;Step 2 - Design your regex&lt;/h2&gt;

&lt;p&gt;The output of &lt;code&gt;certutil -dump&lt;/code&gt; has two key sections &lt;code&gt;Entry 0:&lt;/code&gt; which defines an object delimiter. And &lt;code&gt;Country/region:    `US&#39;&lt;/code&gt; which is the general format of our name value pairs.
&lt;code&gt;&#39;^Entry \d+:&lt;/code&gt; is the first regex we will use. &lt;code&gt;^&lt;/code&gt; represents the start of the line and &lt;code&gt;\d+&lt;/code&gt; represents &amp;ldquo;one or more digits&amp;rdquo; the rest is just direct character matching.
&lt;code&gt;&amp;quot;  (?&amp;lt;variable&amp;gt;[\w\s]+):\s+``(?&amp;lt;value&amp;gt;.*)&#39;&amp;quot;&lt;/code&gt; is the second regex. &lt;code&gt;?&amp;lt;varible&amp;gt;&lt;/code&gt; puts the matched value into a property for use &lt;code&gt;[\w\s]+&lt;/code&gt; matches any number of letter or whitepace characters and &lt;code&gt;.*&lt;/code&gt; is zero or more of any character. Note that the string part of this line starts with a backtick, to include a backtick you need to escape it so `` represents only one backtick.&lt;/p&gt;

&lt;h2 id=&#34;step-3-parse-your-result&#34;&gt;Step 3 - Parse your result&lt;/h2&gt;

&lt;p&gt;This same technique was used to wrap dnscmd before it had native Powershell counterparts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt; #Get the result in a variable
 $result = certutil -dump
 #prepare an array for the objects
    $CAs = @()
    #Parse through the result
    switch -regex ($result){
        &#39;^Entry \d+:&#39;  {
            #When you hit an Entry put the object into the Array and create a new object
            if ($thisEntry){$CAs += $thisEntry}
            $thisEntry = new-object psobject;
        }
        &amp;quot;  (?&amp;lt;variable&amp;gt;[\w\s]+):\s+``(?&amp;lt;value&amp;gt;.*)&#39;&amp;quot;{
            #When you hit a parameter, add it to the object
            $thisEntry | Add-Member -MemberType NoteProperty -Name $matches.variable -value $matches.value -force
        }
    }    
    #If we finish parsing, put the last object in the array
    if ($thisEntry){$CAs += $thisEntry}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that &lt;code&gt;$CAs&lt;/code&gt;` contains our list of CAs!&lt;/p&gt;

&lt;h3 id=&#34;step-4-build-your-function&#34;&gt;Step 4 - Build your function&lt;/h3&gt;

&lt;p&gt;Wrap your code up in a function. As a bonus I have also included a command to list the published templates on each CA.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function get-CAs {
    $result = certutil -dump
    $CAs = @()
    
    switch -regex ($result){
        &#39;^Entry \d+:&#39;  {
            if ($thisEntry){$CAs += $thisEntry}
            $thisEntry = new-object psobject;
        }
        &amp;quot;  (?&amp;lt;variable&amp;gt;[\w\s]+):\s+``(?&amp;lt;value&amp;gt;.*)&#39;&amp;quot;{
            $thisEntry | Add-Member -MemberType NoteProperty -Name $matches.variable -value $matches.value -force
        }
    }    
    if ($thisEntry){$CAs += $thisEntry}
    return $CAs
}

function get-CATemplatesAvailableToIssue ($CA) {
    if (!$CA -or $CA -notmatch &#39;^[\w\.]+\\\w+$&#39;) {
        $CAs = get-CAs
        $CAsToLookup = $CAs | ?{$_.Config -match $CA -or $_.Config -like $CA}
    } else {
        $CAsToLookup = new-object psobject -Property @{Config=$CA}
    }
    foreach ($Ca in $CAsToLookup) {        
        $result = certutil -config $($CA.config) -caTemplates
        switch -regex ($result) {
            &#39;^(?&amp;lt;Name&amp;gt;\w+): (?&amp;lt;DisplayName&amp;gt;.+) -- .+$&#39;{new-object psobject -Property @{Name=$matches.name;DisplayName=$matches.DisplayName;CA=$CA.config}}
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>import-svclog to import SVCLOG files</title>
      <link>http://www.wrish.com/post/use-powershell-to-open-svclog-files/</link>
      <pubDate>Tue, 18 Apr 2017 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/use-powershell-to-open-svclog-files/</guid>
      <description>&lt;p&gt;The Intune connectors dump all their useful information to .svclog files. You can read these files wtih svcTraceViewer.exe which you can get by installing the Windows Communication Foundation SDK.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t want to download the SDK just to get one tool? Do not fear - they are just XML. Here is an imperfect script for reading svclog files.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;function Import-SVCLog {
 [cmdletbinding()]
    Param (
        [parameter(ValueFromPipeline=$True)]
        [string[]]$FileName
    )    
    Process {
       ([xml](&amp;quot;&amp;lt;LogRoot&amp;gt;&amp;quot; + (get-content $fileName) + &amp;quot;&amp;lt;/LogRoot&amp;gt;&amp;quot; )).LogRoot.e2etraceevent | %{            
            $_ | select @{l=&#39;EventID&#39;;e={$_.system.EventID}},@{l=&#39;Type&#39;;e={$_.system.Type}},@{l=&#39;TimeCreated&#39;;e={$_.system.TimeCreated.SystemTime}},@{l=&#39;Source&#39;;e={$_.system.Source.Name}},@{l=&#39;Correlation&#39;;e={$_.system.Correlation.activityID}},@{l=&#39;Computer&#39;;e={$_.system.Computer}},@{l=&#39;Info&#39;;e={$_.ApplicationData}}                       
       }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy the script into your powershell context and then use it like this (for the Exchange connector)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;cd &amp;quot;C:\ProgramData\Microsoft\Windows Intune Exchange Connector\Logs&amp;quot;
dir | import-svclog | out-gridView
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will get a neat graphical interface to sort and view the event data.&lt;/p&gt;

&lt;p&gt;Note that the path to most of the log files for the PKI connector is &lt;code&gt;C:\Program Files\Microsoft Intune\NDESConnectorSvc\Logs\Logs&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Assign EMS licenses to all licensed users</title>
      <link>http://www.wrish.com/post/assign-ems-licenses/</link>
      <pubDate>Mon, 13 Feb 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/assign-ems-licenses/</guid>
      <description>&lt;p&gt;Azure conditional access provides amazingly flexible control over access to Office 365 resources and services based on location/user group membership/device etc. Leveraging it to block access generally requires EMS (Enterprise Mobility + Security) licenses for all users. This short script will assign EMS licenses to all users in your tenant who are licensed but do not have EMS yet.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$VerbosePreference = &amp;quot;Continue&amp;quot;
$SKU = get-msolaccountSKU | ?{$_.accountskuid -match &#39;:EMS$&#39;} | select -expand AccountSKUID
if ($SKU) {
    $LicensingFailures = @{}
   $allUsersThatNeedEMS = get-msoluser -all | ?{$_.islicensed -and !($_.licenses | ?{$_.accountskuid -eq $SKU})}
   $allusersThatNeedEMS | %{
        $u = $_;
        try{ 
            Set-MsolUserLicense -UserPrincipalName $u.userprincipalname -AddLicenses $SKU -ErrorAction Stop
            Write-verbose &amp;quot;Successfully added $SKU to $($u.userprincipalname)&amp;quot; 
        } catch {
            Write-Error &amp;quot;Failed to add $SKU to $($u.userprincipalname) because: $_&amp;quot;
            $LicensingFailures.&amp;quot;$($u.userprincipalname)&amp;quot; = $_
        }
    }
    Write-host &amp;quot;The following failures occurred&amp;quot;
    $LicensingFailures
} else {
    Write-host &amp;quot;No EMS license SKU found&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>User Profile Cleanup</title>
      <link>http://www.wrish.com/post/cleanup-user-profiles/</link>
      <pubDate>Mon, 23 Jan 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/cleanup-user-profiles/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Cleanup-UserProfiles-277a8084&#34;&gt;Download Cleanup-UserProfiles.ps1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Big environments get messy, lots of users, lots of admins, lots of logging in here and there.&lt;/p&gt;

&lt;p&gt;Profiles accumulate, C drive starts to get full, oh the humanity! Fear not humble Admin, on our adventures today we discover how to remove old user profiles with naught but the flick of a WMI method.&lt;/p&gt;

&lt;p&gt;The meat and bonse of this function is getting user profiles and deleting them:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$userprofiles = Get-WmiObject -Class Win32_UserProfile
$userprofiles[$whichOne].delete()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But before we can pull the trigger and send these profiles to the depths, there will be some evaluation of dates, some checking that they aren&amp;rsquo;t important, and some validating using ShouldProcess.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;[CmdletBinding(
     SupportsShouldProcess=$true,
    ConfirmImpact=&amp;quot;High&amp;quot;
  )]param ($computerName= &#39;.&#39;,$AgeLimit=&#39;60&#39;, $Exclude)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By declaring &lt;code&gt;supportsShouldProcess=$true&lt;/code&gt; it means that we can make use of the COnfirm/Force/Whatif because deleting user profiles is surely an activity to be feared. What if you delete a service account profile? Your best friend Greg? Such activities are the folley of adventurous Admins.&lt;/p&gt;

&lt;p&gt;By wrapping our dangerous bits in &lt;code&gt;$Pscmdlet.shouldProcess(&amp;quot;The thing I am about to do&amp;quot;)&lt;/code&gt; we can give the Admin a chance to save their skin, and their friendships.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt; if ($pscmdlet.ShouldProcess($activity)) {
        Write-Verbose &amp;quot;Attempting to $activity&amp;quot;
        $profile.Delete()       
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go forth wayward Admin, delete those profiles, watch as you recover untold disk space and make the data gods smile.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Cleanup-UserProfiles-277a8084&#34;&gt;Download Cleanup-UserProfiles.ps1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Paste an array into a variable</title>
      <link>http://www.wrish.com/post/paste-me-an-array/</link>
      <pubDate>Thu, 19 Jan 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/paste-me-an-array/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve got a list of values, you want that in an array.&lt;/p&gt;

&lt;p&gt;You could copy it to a file, and import it. You could dump it as a string and split it into an array.. or you could &lt;code&gt;Create-ArrayFromPastedText&lt;/code&gt;.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;function Create-ArrayFromPastedText ($returnvalue = &amp;quot;&amp;quot;)
{
    $result = @()
    while ($true) {
        $value = read-host    
        if ($value -eq $returnvalue){
            return $result
        } else {
            $result += $value
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use it like this&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;$MyArray = create-Arrayfrompastedtext
#Here is a read-host line, just copy and paste your list of computers/users etc
Item1
Item2
Item3

#when you enter an empty line the array closes and returns
#if you want your array to include empty lines use the -returnvalue paramter to change
#the value that signifies the end of the array.

#And then just use your array
$MyArray |?{$_ -match &#39;[13]&#39;}
Item1
Item3
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Check if Office 365 has Your Updated ADFS Certificates</title>
      <link>http://www.wrish.com/post/check-adfs-certificates-with-office365-configuration/</link>
      <pubDate>Sun, 15 Jan 2017 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/check-adfs-certificates-with-office365-configuration/</guid>
      <description>&lt;p&gt;Download it here &lt;a href=&#34;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&#34;&gt;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This script has probably lived its useful life, but I&amp;rsquo;m sharing it anyway, because.. well why not!&lt;/p&gt;

&lt;p&gt;When you want to quickly check to see if your published federation metadata (containing your ADFS token signing certificates) exists on Office 365 you can use &lt;code&gt;Get-MsolFederationProperty&lt;/code&gt; that&amp;rsquo;s great if you have one domain.. but what if you have 25 or 50.&lt;/p&gt;

&lt;p&gt;Create a profile on your ADFS servers&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;notepad $profile.alluserscurrenthost
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Copy and paste this into the profile and click save&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;function Check-ADFSFederationForAllDomains {
    
    get-msoldomain | ?{$_.authentication -eq &amp;quot;Federated&amp;quot; -and !$_.rootDomain } | %{
        Write-host Processing $_.Name
        $SETUP = Get-MsolFederationProperty –DomainName $_.Name
        if ($setup[0].TokenSigningCertificate -eq $setup[1].TokenSigningCertificate -and $setup[0].NextTokenSigningCertificate -eq $setup[1].NextTokenSigningCertificate){
            Write-host $_.Name &amp;quot;Token Signing and Next Token Signing Certificates Match&amp;quot; -ForegroundColor Green      
         } else {
            Write-host $_.Name &amp;quot;Token Signing and/or Next Token Signing Certificates DO NOT Match&amp;quot; -ForegroundColor REd    
         }
      } 
}
write-host &#39;Check-ADFSFederationForAllDomains&#39;

Function Update-ADFSFederationForAllDomains ($supportMultipleDomains){
    
    get-msoldomain | ?{$_.authentication -eq &amp;quot;Federated&amp;quot; -and !$_.rootDomain } | %{
        Write-host Processing $_.Name
        Update-MsolFederatedDomain –DomainName $_.Name -SupportMultipleDomain:$supportMultipleDomains
       
      } 
}
Write-Host &#39;Update-ADFSFederationForAllDomains&#39; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when the time comes to check just run &lt;code&gt;Check-ADFSFederationForAllDomains&lt;/code&gt; followed by &lt;code&gt;Update-ADFSFedrationForAllDomains&lt;/code&gt; if you need to update.&lt;/p&gt;

&lt;p&gt;Download it here &lt;a href=&#34;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&#34;&gt;https://gallery.technet.microsoft.com/Check-and-Update-ADFS-3f27ee5e&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Generate an SHA-1 signed certificate after cutover to SHA-2</title>
      <link>http://www.wrish.com/post/switch-ms-pki-back-to-sha1/</link>
      <pubDate>Wed, 04 Jan 2017 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/switch-ms-pki-back-to-sha1/</guid>
      <description>&lt;p&gt;You&amp;rsquo;ve finally made the switch on your Microsoft AD CS PKI infrastructure to SHA2 (SHA256)&amp;hellip; but there is always one.&lt;/p&gt;

&lt;p&gt;One outlier application that won&amp;rsquo;t accept an SHA-2 certificate and needs an SHA1 certificate to keep chugging for 1 more year.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t worry, you can switch your Active Directory Certificate Services PKI infrastructure back to SHA-1 for a little bit.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;certutil -setreg ca\csp\CNGHashAlgorithm SHA1
restart-service certsvc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now issue your certificate, and switch back.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-powershell&#34;&gt;certutil -setreg ca\csp\CNGHashAlgorithm SHA256
restart-service certsvc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that only the leaf certificate will be SHA1, your chain will still be SHA2 - if your application can&amp;rsquo;t handle that then it is out of luck.&lt;/p&gt;

&lt;p&gt;There is a small chance that some auto-enrolled certificate ALSO got issued with an SHA1 certificate. So you can run a quick query to see all the certificates that were issued in the last hour&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;certutil -restrict &amp;quot;SubmittedWhen &amp;gt;= now-00:01, Disposition = 20&amp;quot; -view  csv | ConvertFrom-Csv | fl &amp;quot;Request Submission Date&amp;quot;,&amp;quot;Requester Name&amp;quot;,&amp;quot;Issued Common Name&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you were unlucky and a certificate was issued while you were in SHA1 you may want to go and renew it again.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Office 365 - Convert between Immutable ID and AD Object </title>
      <link>http://www.wrish.com/post/convert-between-immutableid-and-ad-object/</link>
      <pubDate>Thu, 22 Dec 2016 20:53:49 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/convert-between-immutableid-and-ad-object/</guid>
      <description>&lt;p&gt;Two quick scripts to convert between ImmutableIDs and AD Objects with pipeline capability.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;
function get-ImmutableIDfromADObject
{
    [CmdletBinding()] Param(
        [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelinebyPropertyName=$True)]$ADObject) 
   process{ 
        if (!$ADObject.objectguid){$ADObject = get-adobject $AdObject -properties objectGuid}
        [system.convert]::ToBase64String($ADObject.objectguid.tobytearray())
    }
}

function get-ADObjectFromImmutableID{
      [CmdletBinding()] Param(
        [Parameter(Mandatory=$True,ValueFromPipeline=$True,ValueFromPipelinebyPropertyName=$True)][string]$ImmutableID)
   process { get-adobject  ([guid]([system.convert]::FromBase64String($ImmutableID)))}
}

&amp;lt;#
get-aduser shane.wright | get-ImmutableIDfromADObject
6WuADX7LfUa8DVAQGxuZcA==

get-aduser shane.wright | get-ImmutableIDfromADObject | get-ADObjectFromImmutableID

DistinguishedName                          Name         ObjectClass ObjectGUID                          
-----------------                          ----         ----------- ----------                          
CN=Shane Wright,OU=Staff,DC=contoso,DC=com Shane Wright user        0d806be9-cb7e-467d-bc0d-50101b1b9970


get-ADObjectFromImmutableID 6WuADX7LfUa8DVAQGxuZcA==
DistinguishedName                          Name         ObjectClass ObjectGUID                          
-----------------                          ----         ----------- ----------                          
CN=Shane Wright,OU=Staff,DC=contoso,DC=com Shane Wright user        0d806be9-cb7e-467d-bc0d-50101b1b9970
#&amp;gt;

&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>List all of a users group memberships</title>
      <link>http://www.wrish.com/post/list-all-nested-memberships/</link>
      <pubDate>Mon, 19 Dec 2016 19:54:49 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/list-all-nested-memberships/</guid>
      <description>

&lt;p&gt;Download the script &lt;a href=&#34;https://gallery.technet.microsoft.com/Get-nested-group-e9ce3687&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Auditing user access is hard, usually you audit from resource out - eg, finding all Domain Admins, or finding all users with full acecss to &lt;em&gt;SecretShare$&lt;/em&gt; share on &lt;em&gt;SecretServer01&lt;/em&gt;. But occasionally want to audit from user out.. this is hard.. even impossible (if you have a very big environment). Lets talk about the first step &lt;em&gt;Enumerating Nested Groups&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&#34;token-groups&#34;&gt;Token Groups&lt;/h2&gt;

&lt;p&gt;Each user has a constructed attribute called &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ms680275(v=vs.85).aspx&#34;&gt;&lt;code&gt;tokengroups&lt;/code&gt;&lt;/a&gt; that returns a list of all transitive group memberships. You can query &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/ms680275(v=vs.85).aspx&#34;&gt;&lt;code&gt;tokengroups&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;get-adobject&lt;/code&gt; like this&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-PowerShell&#34;&gt;$userDN = &#39;CN=Tom,OU=sales,DC=wrish,DC=com&#39;
get-adobject -SearchBase $userDN -SearchScope Base -Properties TokenGroups  -filter *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; but there are a couple of problems, you get back SIDs and only SIDs, that means no &lt;em&gt;Distribution Only&lt;/em&gt; groups and you have to manually convert them into objects or DNs if you want useful visual reporting. You can do that pretty easily (but slowly) like this&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function get-TokenGroups ($objectDN) {
    $ADObject = get-adobject -SearchBase $objectDN -SearchScope Base -Properties TokenGroups  -filter *
    foreach ($Sid in $ADObject.tokengroups){
        ([ADSI]&amp;quot;LDAP://&amp;lt;SID=$SID&amp;gt;&amp;quot;).distinguishedname
    }       
}
get-TokenGroups  &#39;CN=Tom,OU=sales,DC=wrish,DC=com&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip; also, some groups are missing in a multi-domain environment - &lt;em&gt;Domain Local&lt;/em&gt; groups in remote domains. &lt;em&gt;Domain Local&lt;/em&gt; group memberships aren&amp;rsquo;t replicated to the &lt;em&gt;Global Catalog&lt;/em&gt;, so the GC doesn&amp;rsquo;t add them to the tokengroups value when queried.&lt;/p&gt;

&lt;h2 id=&#34;memberof-evaluation&#34;&gt;MemberOf Evaluation&lt;/h2&gt;

&lt;p&gt;Each user has a &lt;code&gt;MemberOf&lt;/code&gt; attribute which you can query recursively to get at all those juicy remote domain groups. There are plenty of examples of these scripts available they usually commit the various sins of PowerShelling like &lt;a href=&#34;https://gallery.technet.microsoft.com/Export-nested-groups-of-36e761f1&#34;&gt;exporting to csv&lt;/a&gt; or &lt;a href=&#34;https://gallery.technet.microsoft.com/Get-nested-group-15f725f2&#34;&gt;not generating objects at all&lt;/a&gt; or a &lt;a href=&#34;https://gallery.technet.microsoft.com/Get-ADUserNestedGroupMember-d39bb04d&#34;&gt;particularly good one that even outputs some nice verbose info&amp;hellip; but breaks when group memberships traverse domains&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;They are also all incredibly complicated, sigh.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function EnumerateMemberOf($Object, $ResultSoFar=@())
{ 
#Helper function to walk $object&#39;s memberof attribute and list out all group memberships    
    if ($object.memberof){
        $Results =  @();        
        foreach ($group in $Object.memberof){
            #prevent nesting loops trapping by checking to make sure the group hasn&#39;t been searched already
            if ($ResultSoFar -notcontains $Group) {
                #Bind directly to the group with ADSI - this will automatically follow referrals and work with 
                #multi domain forests
                $TempGroup = [ADSI]&amp;quot;LDAP://$Group&amp;quot; ;
                $ResultSoFar += $Group.ToString();
                #Enumerate the next level of memberof
                $Results += EnumerateMemberOf $TempGroup $ResultSoFar ;
                $Results += $Group;
            }            
         }
        return $Results
    } 
}

function get-ADNestedMembership ($Identity) 
    $ADuser = get-aduser $Identity -Properties memberof,distinguishedname,primaryGroup
    write-output (new-object psobject -property @{distinguishedname=$aduser.distinguishedname;&#39;NestedMemberOf&#39;=(@(enumerateMemberof $ADuser)+(enumerateMemberof (get-adgroup $AdUser.primaryGroup -properties memberof)))})
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the advanced functions (with pipline goodness) you&amp;rsquo;ll need to download it &lt;a href=&#34;https://gallery.technet.microsoft.com/Get-nested-group-e9ce3687&#34;&gt;https://gallery.technet.microsoft.com/Get-nested-group-e9ce3687&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Clone OU Structure to New Domain</title>
      <link>http://www.wrish.com/post/clone-ou-structure-to-new-domain/</link>
      <pubDate>Fri, 16 Dec 2016 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/clone-ou-structure-to-new-domain/</guid>
      <description>&lt;p&gt;A quick, semi-powershell way to clone an OU structure from a source domain to a destination domain is to use the &lt;code&gt;ldifde&lt;/code&gt; tool and then just modify the output.

To generate the Output file &lt;code&gt;Oustructure-cleaned.ldif&lt;/code&gt; we use ldifde to export all OUs and then remove the domain name (this is not necessary but helps later).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;$Domain = get-addomain
ldifde -f OUStructure.ldif -d $($domain.Distinguishedname) -c `&amp;quot;$($domain.Distinguishedname)`&amp;quot; `&amp;quot;DC=X`&amp;quot; --% -r &amp;quot;(objectclass=organizationalUnit)&amp;quot; -l &amp;quot;ou,description,objectclass,displayName,displayNamePrintable,msCOM-UserPartitionSetLink,x121Address,uPNSuffixes,co,telexNumber,teletexTerminalIdentifier,telephoneNumber,street,st,seeAlso,searchGuide,registeredAddress,preferredDeliveryMethod,postalCode,postalAddress,postOfficeBox,physicalDeliveryOfficeName,managedBy,thumbnailLogo,l,internationalISDNNumber,facsimileTelephoneNumber,destinationIndicator,desktopProfile,defaultGroup,countryCode,c,businessCategory&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can replace any organisation specific information (if you want your test environment to look like a different organisation)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;get-content OUStructure.ldif | %{$_ -replace &#39;Contoso&#39;,&#39;TailSpin Toys&#39;} | Out-file Oustructure-reOrg.ldif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we copy the ldif file to the target server and execute the commands to load the OU structure&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;$Domain = get-addomain
ldifde -i -v -k -f OUStructure.ldif  -c `&amp;quot;DC=X`&amp;quot; `&amp;quot;$($domain.Distinguishedname)`&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Remotely Retrieve active SSL certificate (HTTPS or LDAPS)</title>
      <link>http://www.wrish.com/post/remotely-retrieve-ssl-certificates/</link>
      <pubDate>Mon, 05 Dec 2016 23:30:10 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/remotely-retrieve-ssl-certificates/</guid>
      <description>&lt;p&gt;When replacing certificates on servers it is nice to be able to verify that the certificate has been updated after you have done the change.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Retreieve-ServerCertFromSoc-baf52fb1&#34;&gt;Download Retrieve-ServerCertFromSocket.ps1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;With websites this tends to be very easy - enter the address in Internet Explorer and doubleclick the padlock to view the certificate. This doesn&amp;rsquo;t
work in lots of situations though - no IE available in the environment, when you are trying to use a particular SNI header that doesn&amp;rsquo;t match your connectivity
method on your client machine, or when you want to get a secure LDAP certificate - port 636 or 3269 from a Domain Controller.&lt;/p&gt;

&lt;p&gt;In the past I have often used openssl with the s_client and showcerts options
&lt;code&gt;openssl s_client -showcerts -host www.wrish.com -port 443&lt;/code&gt;
then you have to copy and paste the output into a file to view the file or review the settings. This requires another piece of software, and remembering the parameters. If only there was a quick and dirty powershell way?!&lt;/p&gt;

&lt;p&gt;To build this script I started looking around for what was already available. I found this one &lt;a href=&#34;https://iamoffthebus.wordpress.com/2014/02/04/powershell-to-get-remote-websites-ssl-certificate-expiration/&#34;&gt;Powershell to get remote website&amp;rsquo;s SSL certificate expiration&lt;/a&gt; but knew it wouldn&amp;rsquo;t work
for me because it relies on &lt;code&gt;Net.HttpWebRequest&lt;/code&gt; which means no LDAPs or other protocols. I had to look lower on the network stack and found &lt;code&gt;System.Net.Sockets.tcpclient&lt;/code&gt; and &lt;code&gt;System.Net.Security.SslStream&lt;/code&gt; which allow you to directly establish an SSL stream, perfect!&lt;/p&gt;

&lt;p&gt;To build out the script I make use of &lt;code&gt;try {} catch {} finally {}&lt;/code&gt; by putting the cleanup commands in the finally block (good practice for all network scripting) you can avoid memory leaks and leaving open unwanted sockets.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Retreieve-ServerCertFromSoc-baf52fb1&#34;&gt;Download Retrieve-ServerCertFromSocket.ps1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Decoding legacy Exchange DN from NDR</title>
      <link>http://www.wrish.com/post/decode-legacy-exchange-dn-from-ndr/</link>
      <pubDate>Fri, 02 Dec 2016 23:47:35 +0000</pubDate>
      
      <guid>http://www.wrish.com/post/decode-legacy-exchange-dn-from-ndr/</guid>
      <description>&lt;p&gt;Occasionally in Exchange you will accidentally or intentionally recreate a user, or delete some values from their object - this will impact the LegacyExchangeDN value. I have seen this happen where mailuser objects were removed from Office 365, the user objects were cloud only and the LegacyExchangeDN was gone forever.&lt;/p&gt;

&lt;p&gt;Contrary to its name, the LegacyExchangeDN value is critical to maintaining active conversations within your organisation. When a user&amp;rsquo;s legacyExchagneDN is lost, collegues replying to conversations with that user will get an NDR. When they create a new email the email will work.&lt;/p&gt;

&lt;p&gt;You can extract the old LegacyExchangeDN from the NDR by finding the string that looks like this &lt;code&gt;IMCEAEX-_O=ExchangeLabs_ou=Exchange+20Administrative+20Group+20+28FYDIBOHF23SPDLT+29_cn=Recipients_cn=wrish+2Eonmicrosoft+2Ecom-53453-Jones+2C+20Martial+20+28dfs9vk29@wrish.com&lt;/code&gt; and use the function below to convert it back to an X500 attribute which you add to the &lt;code&gt;proxyaddresses&lt;/code&gt; attribute of the user.&lt;/p&gt;

&lt;p&gt;Here is the function:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function decode-NDRX500Address ($DN){
    #Generate a list of replacements to be done
    $replacements = @{&#39;^IMCEAEX-&#39;=&#39;&#39;;&#39;_&#39;=&#39;/&#39;;&#39;@.+$&#39;=&#39;&#39;}
    (0..127) | %{$replacements.&amp;quot;\+$(&#39;{0:x}&#39; -f $_)&amp;quot; = &amp;quot;$([char]$_)&amp;quot;}
    #Add X500 to the start
    $replacements.&amp;quot;^&amp;quot; = &amp;quot;X500:&amp;quot;
    #Perform the replacements
    $replacements.GetEnumerator() | %{
        $dn = $dn -replace $_.key,$_.Value
    }
    $DN
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is how you can use it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;$ValueFromNDR = &#39;IMCEAEX-_O=ExchangeLabs_ou=Exchange+20Administrative+20Group+20+28FYDIBOHF23SPDLT+29_cn=Recipients_cn=wrish+2Eonmicrosoft+2Ecom-53453-Jones+2C+20Martial+20+28dfs9vk29@wrish.com&#39;
decode-NDRX500Address $ValueFromNDR
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Track Lync Schema update with Powershell</title>
      <link>http://www.wrish.com/post/track-skype-lync-schema-change/</link>
      <pubDate>Fri, 25 Nov 2016 11:42:35 -0500</pubDate>
      
      <guid>http://www.wrish.com/post/track-skype-lync-schema-change/</guid>
      <description>&lt;p&gt;When I perform schema changes in very large forests it is nice to be able to track the
status of the change as it replicates throughout the forest. I wanted to create a script that
would quickly tell me what the current schema was on over 100 DCs.&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t want to see how it was done you can just &lt;a href=&#34;https://gallery.technet.microsoft.com/Track-Skype-and-Lync-c8151bca&#34;&gt;Download Track-LyncSchema.ps1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Starting with some scripts that I have built before &lt;code&gt;foreach-parallel&lt;/code&gt; to do parallel
processing, &lt;code&gt;get-forestDomainControlles&lt;/code&gt; to get a list of all DCs in the forest
and &lt;code&gt;get-LdapData&lt;/code&gt; to do direct ldap lookups quickly. &lt;code&gt;get-LdapData&lt;/code&gt; is necessary
because it will take too long to import the AD module into each thread of the parallel processor.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;Import-module ActiveDirectory          
function get-ForestDomainControllers () {...}
function get-ldapData ($ldapfilter,$searchRoot,$Server,[switch]$GC,$pageSize=1000,$Properties=&amp;quot;*&amp;quot;,$sizeLimit=0,[switch]$verbose,$o365FilterAddress){...}
function ForEach-Parallel () {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First we need to get all the DCs into an array, this can take a long time for large domains. We will only get the list if $DCs is empty -
this way we can run this script multiple times but only do this step once.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;if ($DCs -eq $null) {$DCs = get-ForestDomainControllers}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we locate the schema partition - likewise we only want to do this once. The &lt;code&gt;PartitionsContainer&lt;/code&gt; value on the AD forest object has a value like &lt;code&gt;DC=Partitions,CN=Configuration,DC=Domain,DC=com&lt;/code&gt;.
We will use &lt;code&gt;-replace&lt;/code&gt; to replace the partitions value with &lt;code&gt;cn=schema&lt;/code&gt; to get the schema partition.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;if ($SchemaPartiton -eq $null) {$SchemaPartition = (get-adforest).partitionscontainer -replace &#39;CN=Partitions&#39;,&#39;CN=Schema&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the Lync Schema version we need the rangeUpper value of the ms-RTC-SIP-SchemaVersion object in the schema partition. To do that, we will use &lt;code&gt;get-ldapdata&lt;/code&gt; with the &lt;code&gt;searchroot&lt;/code&gt; specified as the Lync schema object. In this code &lt;code&gt;$_&lt;/code&gt; represents the server being worked on in the pipeline when we do foreach.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;$Value = get-ldapdata  -searchRoot &amp;quot;CN=ms-RTC-SIP-SchemaVersion,$SchemaPartion&amp;quot; -properties rangeupper -server $_ | select -expand rangeupper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ForEach-Parallel&lt;/code&gt; makes use of worker threads for parallelism, so we need to import the functions into the thread and also any values we want to pass. To get the &lt;code&gt;$SchemaPartition&lt;/code&gt; value into the thread, we pass it using the &lt;code&gt;-Arguments&lt;/code&gt; parameter and then the first
line of the executed code includes &lt;code&gt;$SchemaPartition=$args[0]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Depending on the value, we want to return text that tells us what the version is, for this we use a switch statement&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;switch ($value) {
	&#39;1006&#39; {$value = &amp;quot;LCS 2005 [$value]&amp;quot;}
	&#39;1007&#39; {$value = &amp;quot;OCS 2007 R1 [$value]&amp;quot;}
	&#39;1008&#39; {$value = &amp;quot;OCS 2007 R2 [$value]&amp;quot;}
	&#39;1100&#39; {$value = &amp;quot;Lync Server 2010 [$value]&amp;quot;}
	&#39;1150&#39; {$value = &amp;quot;Skype for Business 2015 [$value]&amp;quot;}
	default: {$value = &amp;quot;Unknown schema value or no value [$value]&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we export the value to an object so that it looks like a nice table and we can manipulate it if we want.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;new-object psobject -Property @{server=$_;LyncSchemaVersion=$value}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function that does the work looks like this. The &lt;code&gt;foreach-parallel&lt;/code&gt; command ends with &lt;code&gt;-ImportFunctions&lt;/code&gt; to import the &lt;code&gt;get-ldapdata&lt;/code&gt; into scope of each thread.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;function track-LyncSchema {
    $DCs.hostname |  %p{
        $SchemaPartition= $args[0]
        $Value = get-ldapdata  -searchRoot &amp;quot;CN=ms-RTC-SIP-SchemaVersion,$SchemaPartition&amp;quot; -properties rangeupper -server $_ | select -expand rangeupper
        switch ($value) {
            &#39;1006&#39; {$value = &amp;quot;LCS 2005 [$value]&amp;quot;}
            &#39;1007&#39; {$value = &amp;quot;OCS 2007 R1 [$value]&amp;quot;}
            &#39;1008&#39; {$value = &amp;quot;OCS 2007 R2 [$value]&amp;quot;}
            &#39;1100&#39; {$value = &amp;quot;Lync Server 2010 [$value]&amp;quot;}
            &#39;1150&#39; {$value = &amp;quot;Skype for Business 2015 [$value]&amp;quot;}
            default {$value = &amp;quot;Unknown [$value]&amp;quot;}
        }

        new-object psobject -Property @{server=$_;LyncSchemaVersion=$value}
    } -ImportFunctions get-ldapData -arguments $schemaPartition
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We call the script from the commandline to get a list of all the servers and the schema version.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;. .\track-LyncSchema.ps1
server                        LyncSchemaVersion
------                        -----------------
TestDC100.wrish.com           Skype for Business 2015 [1...
TestDC101.wrish.com           Skype for Business 2015 [1...
TestDC213.wrish.com           Skype for Business 2015 [1...
TestDC12.wrish.com            Skype for Business 2015 [1...
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because we built the script to output objets, we can easily see how many are left to replicate.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-Powershell&#34;&gt;. .\track-lyncschema.ps1 | group LyncSchemaVersion
Count Name                       Group
----- ----                       -----
  202 Skype for Business 2010... {@{server=Test..
   20 Lync Server 2010 [1100]    {@{server=Test..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;https://gallery.technet.microsoft.com/Track-Skype-and-Lync-c8151bca&#34;&gt;Download Track-LyncSchema.ps1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>